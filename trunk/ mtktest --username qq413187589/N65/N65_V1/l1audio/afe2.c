/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 *
 * Filename:
 * ---------
 * afe2.c
 *
 * Project:
 * --------
 *   Maui_sw
 *
 * Description:
 * ------------
 *   Audio Front End
 *
 * Author:
 * -------
 * -------
 *
 *------------------------------------------------------------------------------
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 *
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 *******************************************************************************/
#include "l1audio_def.h"
#include "afe.h"
#include "l1sp_trc.h"
#include "am.h"

#if !defined(MT6205B)

/// DC Couple is in testing phase. After verficiation,
/// the variable AFE_DC_Couple_Mode shall be put into custom folder.
const kal_bool AFE_DC_Couple_Mode = KAL_FALSE;

#define UNIT_TEST_AFE2 0

#if defined(MT6226) || defined(MT6226D) || defined(MT6226M) || defined(MT6227) || defined(MT6227D)  /* for fixing a MT6226/27 analog circuit bug */
#include "init.h"
#endif

#define AAPDN_POWER_DOWN   0x000
#define AAPDN_BIAS_DAC_ON  0x01C
#define AAPDN_ALL_ON       0x0FF

#define PDN_CON2_AAFE       0x1000
#define PDN_CON2_VAFE       0x0100

#if defined(MT6217) || defined (MT6219) || defined(MT6225)
#define HW_AGC_SETTING     0x458F
#elif defined(MT6226) || defined(MT6226D) || defined(MT6226M) || defined (MT6227) || defined(MT6227D) || defined (MT6228) || defined (MT6229) || defined (MT6230) || defined(MT6223) || defined(MT6223P) || defined(MT6235) || defined(MT6238) 
#define HW_AGC_SETTING     0x4587
#else
#error The new chip should configure suitable AGC
#endif

#define FM_RADIO_RECORDING_VOLUME   5

kal_uint32 SaveAndSetIRQMask(void);
void RestoreIRQMask(kal_uint32);
extern const uint16 Ext_op_on_delay;
extern const uint16 Ext_op_off_delay;
/* --------------------------------------------------------------------------------------------------------------------- */

typedef struct {
   volatile uint16*  addr;
   uint16            val;
} DelayCmd;

struct {
   /// Speaker usage flag
   /// bit n : aud function n
   /// [Set|Clear] by AFE_Turn[On|Off]Speaker
   kal_uint16     sp_flag;
   /// FIR filter usage flag
   /// bin n: aud function n
   /// [Set|Clear] by AFE_Turn[On|Off]FIR
   kal_uint16     fir_flag;
   /// Microphone usage flag
   /// bin n: aud function n
   /// [Set|Clear] by AFE_Turn[On|Off]Microphone
   kal_uint16     mic_flag;
   /// L1SP_LNA_0, L1SP_LNA_1, or L1SP_LNA_FMRR
   kal_uint8      mic_src;
   kal_uint8      mic_volume;
   kal_bool       mic_mute;
   kal_bool       accessory_flag;
   kal_uint8      sidetone_volume;   
   kal_bool       sidetone_disable;  /// sidetone disable flag
   struct   {
      /// L1SP_SPEAKER1, L1SP_SPEAKER2, or L1SP_LOUDSPEAKER
      /// Set by AFE_SetOutputDevice
      kal_uint8   out_dev;
      kal_uint8   volume;
      kal_int8    digital_gain_index;
      kal_uint16  digital_gain;
      kal_uint8   digital_gain_level;/// digital gain level
      kal_bool    mute;
   } aud[L1SP_MAX_AUDIO];      
   kal_uint16     aud_id;          
   /// for controlling external amplifier
   kal_bool       gpio_lock;
   kal_bool       ext_op_on;
   kal_bool       mute;  /// for mute AFE    
   kal_bool       refresh;
   kal_bool       loopback; 
   kal_bool       v8k_off_request;    
   kal_bool       aClk_off_request; 
   RINGBUFFER_T(DelayCmd,4)  regq;   
#if defined(EXT_DAC_SUPPORT) 
   /// for controlling external DAC      
   kal_bool       ext_dac_i2s_on;
   kal_bool       ext_dac_add_st;
   kal_bool       ext_dac_mute;   
   kal_int8       ext_dac_aud_func;  
   kal_uint8      ext_dac_aud_vol; 
   kal_uint16     ext_dac_freq;   
   kal_uint16     ext_dac_level_gain;               
#endif    
   kal_int16      ext_op_delay; 
#if (!defined(MT6219)&&!defined(MT6205)&&!defined(MT6205B)&&!defined(MT6219B)&&!defined(MT6217))
   kal_bool       toneLoopbackRec;
#endif
} afe;


#if defined(EXT_DAC_SUPPORT)
// mcu\media\audio\include
#include "aud_defs.h"  
// mcu\ps\l4\include
#include "device.h"     
extern kal_uint8 aud_get_volume_gain(kal_uint8 mode, kal_uint8 type, kal_uint8 level);
extern void aud_get_melody_volume_setting(kal_uint8 mode, kal_uint8 *MaxAnalogGain, kal_uint8 *step);
extern kal_bool audio_tv_cable_in;
#endif 

/*****************************************************************************
* FUNCTION
*  Set_AFE_VAC_CON0_VCALI
* DESCRIPTION
*   This function is to set AFE_VAC_CON0::VCALI.
*   0x0 for 6226/6227 6228/6229+D63216
*   0xF for 6205/6217/6218/6219 6228/6229+C63216
*
*   ACIF_AC_HW_VER:
*     MT6228/MT6229
*     C63216D:0x8C01
*     D63216A:0x8D00
* PARAMETERS
*  None
* RETURNS
*  None
* GLOBALS AFFECTED
*  None
*****************************************************************************/
static void Set_AFE_VAC_CON0_VCALI( void )
{
#if defined(MT6228) || defined(MT6229) || defined(MT6230) || defined(MT6225) || defined(MT6268T) || defined(MT6223) || defined(MT6223P) || defined(MT6235) || defined(MT6238)
   if (0x8C01 == *ACIF_AC_HW_VER) {
      *AFE_VAC_CON0  = (*AFE_VAC_CON0 & 0xFFE0) | 0x0F;
   } else {
      *AFE_VAC_CON0  = (*AFE_VAC_CON0 & 0xFFE0) | 0x00;
   }
#elif defined(MT6226) || defined(MT6226D) || defined(MT6226M) || defined(MT6227) || defined(MT6227D) 
   *AFE_VAC_CON0  = (*AFE_VAC_CON0 & 0xFFE0) | 0x00;
#else
   /// MT6205/6217/6218/6219
   *AFE_VAC_CON0  = (*AFE_VAC_CON0 & 0xFFE0) | 0x0F;
#endif
}



/* --------------------------------------------------------------------------*/



void AFE_SetSamplingRate( uint32 freq )
{
   
#if defined(MT6228) || defined(MT6225) || defined(MT6229) || defined(MT6230) || defined(MT6268T) || defined(MT6223) || defined(MT6223P) || defined(MT6235) || defined(MT6238)
	*AFE_AMCU_CON1 &= ~0x0C00;

   *AFE_AMCU_CON1 |= 0x0800;  // turn on HW EQ
/*
	switch(freq)
	{
		case 0x40:
		case 0x41:
		case 0x42:
		      *AFE_AMCU_CON1 |= 0x0800;  // turn on HW EQ
		      break;
		case 0x20:
		case 0x21:
		case 0x22:
		      *AFE_AMCU_CON1 |= 0x0400;
		      break;
		case 0x00:
		case 0x11:
		case 0x12:
		      *AFE_AMCU_CON1 |= 0x0000;
		      break;
		default:
		      *AFE_AMCU_CON1 |= 0x0C00;
		      break;
	}
*/
#endif

#if defined(EXT_DAC_SUPPORT) 
   switch (freq) {
      case 0x00: 
      case 0x20:
      case 0x40:     
         afe.ext_dac_freq = 32000;     
         break;
      case 0x11:
      case 0x21:  
      case 0x41:
         afe.ext_dac_freq = 44100;
         break;
      case 0x12: 
      case 0x22:  
      case 0x42: 
         afe.ext_dac_freq = 48000;
         break;
   }
#endif    
	
}


void AFE_TurnOn8K( void )
{
#ifdef L1D_TEST
extern  int  PollLoopbackMode(void);
   if( PollLoopbackMode() !=1 )
#endif
   {
      afe.v8k_off_request = KAL_FALSE;
      *PDN_CLR2        =  PDN_CON2_VAFE;
      *AFE_VMCU_CON    |= 0x0001;
      L1Audio_Msg_AFE_Switch( L1AUDIO_Str_onoff(1), AFE_Switch_Name(0) );
#if defined(MT6228) || defined(MT6225) || defined(MT6226) || defined(MT6226D) || defined(MT6226M) || defined(MT6227) || defined(MT6227D) || defined(MT6229) || defined(MT6230) || defined(MT6268T) || defined(MT6223) || defined(MT6223P) || defined(MT6235) || defined(MT6238)
      *DP_8K_LIMITER_CTRL |= 0x1;
#endif       
   }
}

void AFE_TurnOff8K( void )
{
   afe.v8k_off_request = KAL_TRUE;   
}

void AFE_TurnOff8K_Direct( void )
{   
   *PDN_SET2       = PDN_CON2_VAFE;
   *AFE_VMCU_CON  &= ~0x0001;
}


/* --------------------------------------------------------------------------*/
void AFE_TurnOnAudioClock( kal_uint8 clock )
{
   afe.aClk_off_request = KAL_FALSE;   
   *PDN_CLR2       = PDN_CON2_AAFE;
   *AFE_AMCU_CON0 |= 0x0001;
   *AFE_AMCU_CON1 = (*AFE_AMCU_CON1 & ~3) | (clock & 3);
}

void AFE_TurnOffAudioClock( void )
{
   afe.aClk_off_request = KAL_TRUE;    
}

void AFE_TurnOnWTDMA( void )
{
   *PDN_CLR0      = 0x0008;
}

void AFE_TurnOffWTDMA( void )
{
   *PDN_SET0      = 0x0008;
}

// For hardware equalizer
// The coefficient can be written into register only when the power is on
void AFE_TurnOnAudioPower( void )
{
   *PDN_CLR2       = PDN_CON2_AAFE;
}

/* --------------------------------------------------------------------------*/
/// Caller: Task, CTIRQ ISR
void AFE_TurnOnDAI( void )
{
   *AFE_VDB_CON |= 0x0020;

   L1Audio_Msg_AFE_Switch( L1AUDIO_Str_onoff(1), AFE_Switch_Name(1) );
}

void AFE_TurnOffDAI( void )
{
   *AFE_VDB_CON &= ~0x0020;

   L1Audio_Msg_AFE_Switch( L1AUDIO_Str_onoff(0), AFE_Switch_Name(1) );
}

/* --------------------------------------------------------------------------*/
void AFE_TurnOnBluetooth( kal_uint16 param )
{
   ASSERT( (*AFE_VDB_CON & 0x0020) == 0 );   /* To make sure that BT and DAI are not turned simultaneously */

   *AFE_VDB_CON    |= (0x0010 | param );
}

void AFE_TurnOffBluetooth( void )
{
   *AFE_VDB_CON    &= ~0x0010;
}

#if (!defined(MT6219)&&!defined(MT6205)&&!defined(MT6205B)&&!defined(MT6219B)&&!defined(MT6217))
void AFE_EnableToneLoopBackFlag( kal_bool param )
{
   if(param)
      afe.toneLoopbackRec = KAL_TRUE;
   else
      afe.toneLoopbackRec = KAL_FALSE;
}
#endif

/* --------------------------------------------------------------------------*/
/// External DAC Interface
/// fmt: 1 = I2S, 0 = EIAJ
/// cycle: 32 or 16
void AFE_TurnOnEDI( kal_uint16 fmt, kal_uint16 cycle )
{   
   ASSERT( fmt < 2 );
   ASSERT( cycle == 16 || cycle == 32 );
   *AFE_VDB_CON |= 0x0040;
   *AFE_EDI_CON = (((cycle-1)<<2) | (fmt<<1) | 1);
}

void AFE_TurnOffEDI( void )
{
	*AFE_EDI_CON &= ~0x0001;
   *AFE_VDB_CON &= ~0x0040;
}

kal_bool AFE_IsEDIOn( void )
{
   if (*AFE_VDB_CON & 0x0040)
      return KAL_TRUE;
   else
      return KAL_FALSE;
}

/* --------------------------------------------------------------------------*/
/// Caller: Task
void AFE_TurnOnLoopback( void )
{
#if defined(MT6225) || defined(MT6223) || defined(MT6223P)
   *AFE_VLB_CON |= 0x02;     // for digital loopback
#else
   *AFE_VAC_CON1 |= 0x01;    // for analog loopback
#endif
   afe.loopback = KAL_TRUE;   
#if defined(MT6235) || defined(MT6238)
   *AFE_VAGC_CON0 &= ~0x1;
#else
   *AFE_VAGC_CON = 0x0;      // turn off AGC when entering loopback test  
#endif
   ASSERT(!kal_if_hisr());
   kal_trace(TRACE_STATE, AFE_SWITCH_LOOPBACK, '+');
}

void AFE_TurnOffLoopback( void )
{
#if defined(MT6225) || defined(MT6223) || defined(MT6223P)
   *AFE_VLB_CON &= ~0x02;    // for digital loopback
#else
   *AFE_VAC_CON1 &= ~0x01;   // for analog loopback
#endif
   afe.loopback = KAL_FALSE;
   ASSERT(!kal_if_hisr());
   kal_trace(TRACE_STATE, AFE_SWITCH_LOOPBACK, '-');
}

/* --------------------------------------------------------------------------*/
void AFE_SetInputSource( kal_uint8 src )
{
   afe.mic_src       = src;

   afe.refresh = KAL_TRUE;

   ASSERT(!kal_if_hisr());
   kal_trace(TRACE_STATE, AFE_SET_INPUT_SRC, src);
}

kal_uint8 AFE_GetInputSource( void )
{
   return afe.mic_src;
}

void AFE_SetMicrophoneVolume( kal_uint8 mic_volume )
{
#if defined(MT6235) || defined(MT6238)
   afe.mic_volume = mic_volume >> 2; /* Totally 6 bits for VUPG control */
#else
   afe.mic_volume = mic_volume >> 3; /* Totally 5 bits for VUPG control */
#endif

   afe.refresh = KAL_TRUE;

   ASSERT(!kal_if_hisr());
   kal_trace(TRACE_STATE, AFE_SET_MIC_VOLUME, mic_volume);
}

kal_uint8 AFE_GetMicrophoneVolume( void )
{
#if defined(MT6235) || defined(MT6238)
   return afe.mic_volume << 2;  /* Totally 6 bits for VUPG control */
#else
   return afe.mic_volume << 3;  /* Totally 5 bits for VUPG control */
#endif
}

void AFE_SetSidetoneVolume( kal_uint8 sidetone_volume )
{
   afe.sidetone_volume   = sidetone_volume;

   afe.refresh = KAL_TRUE;

   ASSERT(!kal_if_hisr());
   kal_trace(TRACE_STATE, AFE_SET_SIDETONE_VOLUME, sidetone_volume);
}

kal_uint8 AFE_GetSidetoneVolume( void )
{
   return afe.sidetone_volume;
}

void AFE_SetSidetone( kal_bool ec )
{
   afe.sidetone_disable = (ec == 0);
   afe.refresh = KAL_TRUE;
}

/*****************************************************************************
* FUNCTION
*  AFE_SetOutputDevice
* DESCRIPTION
*   This function is to set the output device of an audio function.
*
* PARAMETERS
*  aud_func - the audio function
*  device - be L1SP_SPEAKER1, L1SP_SPEAKER2, or L1SP_LOUDSPEAKER
* RETURNS
*  None
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void AFE_SetOutputDevice( kal_uint8 aud_func, kal_uint8 device )
{
#if defined(EXT_DAC_SUPPORT)   
   if(device & (L1SP_EXT_DAC_BUF0 | L1SP_EXT_DAC_BUF1))
   {
      if(!(device & L1SP_BUFFER_ST))
      {
         switch((SND_SRC_MAP>>aud_func*2)&3) 
         { 
            case SRC_AUDIO_DAC:
               afe.ext_dac_add_st = KAL_TRUE;                 
            case SRC_VOICE_DAC:   
            case SRC_EXT_INPUT:
               device |= L1SP_BUFFER_ST;
               break;
         }               
      }
      else 
         afe.ext_dac_add_st = KAL_FALSE;                  
   }    
#endif    

   afe.aud[aud_func].out_dev = device;   

   afe.refresh = KAL_TRUE;

   ASSERT(!kal_if_hisr());
   kal_trace(TRACE_STATE, AFE_SET_OUTPUT_DEVICE, aud_func, device);
}

kal_uint8 AFE_GetOutputDevice( kal_uint8 aud_func )
{
   return afe.aud[aud_func].out_dev;
}

/*****************************************************************************
* FUNCTION
*  AFE_SetOutputVolume
* DESCRIPTION
*   This function is to set the output volume of an audio function.
*
* PARAMETERS
*  aud_func - the audio function
*  volume - range is from 0 to 255
* RETURNS
*  None
* GLOBALS AFFECTED
*  None
*****************************************************************************/

/// the value of the table is in 1.15 fixed-point
/// -64 dB = 20 log x => x = math.pow(10.0, -64.0/20) * 0x8000
static const kal_uint16 digital_gain_8db_table[8] = {
     21, /// -64 dB
     52, /// -56 dB
    130, /// -48 dB
    328, /// -40 dB
    823, /// -32 dB
   2068, /// -24 dB
   5193, /// -16 dB
  13045  ///  -8 dB
};

/// the value of the table is in 1.14 fixed-point
/// 0.5 dB = 20 log x => x = math.pow(10.0, 0.5/20) * 0x4000
static const kal_uint16 digital_gain_halfdb_table[15] = {
  17355, /// 0.5 dB
  18383, /// 1.0 dB
  19472, /// 1.5 dB
  20626, /// 2.0 dB
  21848, /// 2.5 dB
  23143, /// 3.0 dB
  24514, /// 3.5 dB
  25967, /// 4.0 dB
  27506, /// 4.5 dB
  29135, /// 5.0 dB
  30862, /// 5.5 dB
  32690, /// 6.0 dB
  34627, /// 6.5 dB
  36679, /// 7.0 dB
  38853  /// 7.5 dB
};

kal_uint16 _converted_digital_gain(kal_int8 digital_gain_index)
{
   kal_int8 converted_gain_index;
   kal_uint16 digital_gain; /// 1.15 fixed-point
   
   /// Uncomment the following to make sure MMI code is ready.
   ///ASSERT(digital_gain_index <= 0);
   converted_gain_index = digital_gain_index;
   if (0 == converted_gain_index) {
      digital_gain = 0x8000; /// 0 dB, special case
   } else {
      converted_gain_index = digital_gain_index + 128;
      /// Uncomment the following to make sure MMI code is ready.
      ///ASSERT(converted_gain_index >= 0);
      /// converted_gain_index: 0:-64dB, 1:-63.5dB, 127:-0.5dB
      digital_gain = digital_gain_8db_table[converted_gain_index>>4];
      if ((converted_gain_index&0x0F) > 0) {
         digital_gain = ((kal_uint32)digital_gain * digital_gain_halfdb_table[(converted_gain_index&0x0F)-1]) >> 14;
      }
   }
   return digital_gain;      
}
   

/// digital_gain_index: 0:0dB, -1:-0.5dB, ..., -128:-64dB
void AFE_SetOutputVolume( kal_uint8 aud_func, kal_uint8 volume1, kal_int8 digital_gain_index )
{   
   afe.aud[aud_func].volume = volume1;
   afe.aud[aud_func].digital_gain_index = digital_gain_index;
   afe.aud[aud_func].digital_gain = _converted_digital_gain(digital_gain_index);

#if defined(EXT_DAC_SUPPORT) 
   // Note : extrenal DAC is used as earphone or TV-out only 
   // case 1 : play amr with melody volume (7-level case)  
   if(aud_func == L1SP_VOICE && (afe.aud[L1SP_VOICE].out_dev & (L1SP_EXT_DAC_BUF0|L1SP_EXT_DAC_BUF1)))
   {
      kal_uint32 i, type;
      if(!(afe.aud[L1SP_VOICE].out_dev & L1SP_BUFFER_EXT) && (volume1 != 0)) // for play both case : apply AFE gain is OK 
      {
      #if defined(TV_OUT_SUPPORT)   
         if(audio_tv_cable_in)
            type = AUD_VOLUME_TVO;
         else 
      #endif    
            type = AUD_VOLUME_MEDIA;    
         for(i = 0 ; i < AUD_MAX_VOLUME_LEVEL ; i ++)
         {            
            // find the closest level
            if(aud_get_volume_gain(VOL_HEADSET, type, i) > volume1) 
               break;
         }            
         if(i > 0) i--;
         afe.aud[aud_func].volume = aud_get_volume_gain(VOL_HEADSET, AUD_VOLUME_SPH, i); // apply speech volume       
      }    
   }
   
   // case 2 : play Audio both on earphone and LoudSpk 
   if(aud_func == L1SP_AUDIO && (afe.aud[L1SP_AUDIO].out_dev & (L1SP_EXT_DAC_BUF0|L1SP_EXT_DAC_BUF1)))
   {
      if((afe.aud[L1SP_AUDIO].out_dev & L1SP_BUFFER_EXT) && (volume1 != 0)) // play both 
      {
         kal_uint32 i, type;
         for(i = 0 ; i < AUD_MAX_VOLUME_LEVEL ; i ++)
         {              
            //  find the closest level 
            if(aud_get_volume_gain(VOL_NORMAL, AUD_VOLUME_MEDIA, i) > volume1)
               break;            
         }          
         if(i > 0) i--;
      #if defined(TV_OUT_SUPPORT)            
         if(audio_tv_cable_in)
            type = AUD_VOLUME_TVO;
         else 
      #endif    
            type = AUD_VOLUME_MEDIA;    
         afe.ext_dac_aud_vol = aud_get_volume_gain(VOL_HEADSET, type, i);         
      }
      else 
         afe.ext_dac_aud_vol = volume1;  
   }
   
   if(afe.ext_dac_i2s_on)
   { 
      if(((SND_SRC_MAP>>aud_func*2)&3) == SRC_AUDIO_DAC) 
      {            
         EXT_DAC_SetVolume(afe.aud[aud_func].out_dev & (L1SP_EXT_DAC_BUF0|L1SP_EXT_DAC_BUF1), afe.ext_dac_aud_vol);  
      }
   }
   
   
#endif    
   
   afe.refresh = KAL_TRUE;

   ASSERT(!kal_if_hisr());
   kal_trace(TRACE_STATE, AFE_SET_OUTPUT_VOLUME, aud_func, volume1, digital_gain_index);
}

/*****************************************************************************
* FUNCTION
*  AFE_SetLevelVolume
* DESCRIPTION
*   This function is to set the proper analog gain and digital gain 
*   based on a MaxAnalogGain and the desired (step * 0.5* level)dB attenuation. 
* 
* PARAMETERS
*  aud_func - the audio function
*  MaxAnalogGain - the maximum volume without any attenuation 
*  step - attenuation step quantity , 0.5dB unit   
*  level - the multiplier of attenuation step; 
*          so the total attenuation is (step * 0.5* level)dB  
*
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void AFE_SetLevelVolume(kal_uint8 aud_func, kal_uint8 MaxAnalogGain, kal_uint8 step, kal_uint8 level)
{
   uint8 out_dev, vol_step, vol_step_unit;
   uint8 a_gain, a_atten, d_atten;
                                        
   out_dev = afe.aud[aud_func].out_dev; 

#if defined(EXT_DAC_SUPPORT)  
   // Note : extrenal DAC is used as earphone or TV-out only 
   // case 1 : play amr with melody volume (7-level case)  
   if(aud_func == L1SP_VOICE && (out_dev & (L1SP_EXT_DAC_BUF0|L1SP_EXT_DAC_BUF1)))
   {     
      if(!(out_dev & L1SP_BUFFER_EXT)) // for play both case : apply AFE gain is OK 
      {
         // use AFE gain 
          aud_get_melody_volume_setting(VOL_NORMAL, &MaxAnalogGain, &step);
      }    
   }
   
   // case 2 : play Audio both on earphone and LoudSpk 
   if(aud_func == L1SP_AUDIO && (out_dev & (L1SP_EXT_DAC_BUF0|L1SP_EXT_DAC_BUF1)))
   {
      uint8 ext_dac_max_vol, ext_dac_step;
      if(afe.aud[L1SP_AUDIO].out_dev & L1SP_BUFFER_EXT) // play both 
      {
      #if defined(TV_OUT_SUPPORT)            
         if(audio_tv_cable_in)
            aud_get_melody_volume_setting(VOL_TV_OUT, &ext_dac_max_vol, &ext_dac_step);
         else 
      #endif    
            aud_get_melody_volume_setting(VOL_HEADSET,&ext_dac_max_vol, &ext_dac_step);            
      }
      else 
      {
         ext_dac_max_vol = MaxAnalogGain;  
         ext_dac_step = step;
      }
         
         
      a_gain = ext_dac_max_vol / L1SP_EXT_DAC_STEP;

      a_atten = (ext_dac_step * level) / L1SP_EXT_DAC_STEP_UNIT; 
      d_atten = (ext_dac_step * level) % L1SP_EXT_DAC_STEP_UNIT; 
      ASSERT(d_atten == 0); // For current EXT_DAC interface, this must be 0.
      
      if(a_gain >= a_atten)  
         a_gain -= a_atten;
      else 
      {
         a_atten -= a_gain;
         a_gain = 0;
         d_atten += a_atten * L1SP_EXT_DAC_STEP_UNIT;
         if(d_atten > 128)
            d_atten = 128;
      }
      
      afe.ext_dac_aud_vol = a_gain * L1SP_EXT_DAC_STEP;  
                  
      if(afe.ext_dac_i2s_on)                        
         EXT_DAC_SetVolume(out_dev & (L1SP_EXT_DAC_BUF0|L1SP_EXT_DAC_BUF1), afe.ext_dac_aud_vol);                                                 
   }          
#endif 

   // if L1SP_BUFFER_1 and L1SP_BUFFER_ST both sounds , base on L1SP_BUFFER_1 rather than L1SP_BUFFER_ST
   vol_step = 16;   
   vol_step_unit = 4; // 2dB = 4 * 0.5dB  
   if(!(out_dev & (L1SP_BUFFER_0|L1SP_BUFFER_1)) && (out_dev & L1SP_BUFFER_ST) )                            
      vol_step_unit = 6;  // 3dB = 6 * 0.5dB          
   
   a_gain = MaxAnalogGain / vol_step;

   a_atten = (step * level) / vol_step_unit; 
   d_atten = (step * level) % vol_step_unit; 

   if(a_gain >= a_atten)  
      a_gain -= a_atten;
   else 
   {
      a_atten -= a_gain;
      a_gain = 0;
      d_atten += a_atten * vol_step_unit;
      if(d_atten > 128)
         d_atten = 128;
   }
               
   afe.aud[aud_func].volume = a_gain * vol_step + 1; // plus 1 to avoid volume == 0 (this will turn off speaker) 
   afe.aud[aud_func].digital_gain_index = 0 - d_atten; 
   afe.aud[aud_func].digital_gain = _converted_digital_gain( 0-d_atten);       
   afe.refresh = KAL_TRUE;
}  

void  AFE_GetOutputVolume( kal_uint8 aud_func, kal_uint8 *volume1, kal_int8 *digital_gain_index )
{
   *volume1 = afe.aud[aud_func].volume;
   *digital_gain_index = afe.aud[aud_func].digital_gain_index;
}

void AFE_SetDigitalGain( kal_uint8 aud_func, kal_uint8 level )
{
   ASSERT(level<=100);

#if defined(__BT_SUPPORT__)
   if(AM_IsBluetoothOn()) {
      /// for the case of bluetooth use 
      return;
   }
#endif
   afe.aud[aud_func].digital_gain_level = level;
#if defined(EXT_DAC_SUPPORT)
   if( aud_func == L1SP_AUDIO )
      afe.ext_dac_level_gain = ((kal_uint32)level * 0x8000) / 100;
#endif
   afe.refresh = KAL_TRUE;
}

/*****************************************************************************
* FUNCTION
*  AFE_TurnSpeakerOn
* DESCRIPTION
*   This function is to turn on the speaker of an audio function.
*
* PARAMETERS
*  aud_func - the audio function
* RETURNS
*  None
* CALLER
*  Task
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void AFE_TurnOnSpeaker( kal_uint8 aud_func )
{
   kal_uint32 savedMask;

   savedMask = SaveAndSetIRQMask();    /* Disable interrupt to prevent race condition */  
   afe.sp_flag |= (1<<aud_func);
   RestoreIRQMask(savedMask); 
   afe.refresh = KAL_TRUE;   
              
   L1Audio_Msg_AFE_TurnSpk( L1AUDIO_Str_onoff(1), L1AUDIO_Func_Name(aud_func) );
}

void AFE_MuteSpeaker( kal_uint8 aud_func, kal_bool mute )
{
   afe.aud[aud_func].mute = mute;

   afe.refresh = KAL_TRUE;
}

/*****************************************************************************
* FUNCTION
*  AFE_TurnSpeakerOff
* DESCRIPTION
*   This function is to turn off the speaker of an audio function.
*
* PARAMETERS
*  aud_func - the audio function
* RETURNS
*  None
* CALLER
*  Task, L1Audio_HISR(via AM_AudioPlaybackOff)
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void AFE_TurnOffSpeaker( kal_uint8 aud_func )
{
   kal_uint32 savedMask;

   savedMask = SaveAndSetIRQMask();    /* Disable interrupt to prevent race condition */
   afe.sp_flag &= ~(1<<aud_func);
   RestoreIRQMask(savedMask);
   afe.refresh = KAL_TRUE;
      
   L1Audio_Msg_AFE_TurnSpk( L1AUDIO_Str_onoff(0), L1AUDIO_Func_Name(aud_func) );
}

/*****************************************************************************
* FUNCTION
*  AFE_TurnOnFIR
* DESCRIPTION
*   This function is to turn on the FIR filter of an audio function.
*
* PARAMETERS
*  aud_func - the audio function
* RETURNS
*  None
* CALLER
*  Task
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void AFE_TurnOnFIR( kal_uint8 aud_func )
{
   kal_uint32 savedMask;

   /// Disable interrupt to prevent race condition
   savedMask = SaveAndSetIRQMask();
   afe.fir_flag |= (1<<aud_func);
   RestoreIRQMask(savedMask);

   afe.refresh = KAL_TRUE;

   ASSERT(!kal_if_hisr());
   kal_trace(TRACE_STATE, AFE_SWITCH_FIR, '+', aud_func);
}

/*****************************************************************************
* FUNCTION
*  AFE_TurnFirOff
* DESCRIPTION
*   This function is to turn off the FIR filter of an audio function.
*
* PARAMETERS
*  aud_func - the audio function
* RETURNS
*  None
* CALLER
*  Task
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void AFE_TurnOffFIR( kal_uint8 aud_func )
{
   kal_uint32 savedMask;

   /// Disable interrupt to prevent race condition
   savedMask = SaveAndSetIRQMask();
   afe.fir_flag &= ~(1<<aud_func);
   RestoreIRQMask(savedMask);

   afe.refresh = KAL_TRUE;

   ASSERT(!kal_if_hisr());
   kal_trace(TRACE_STATE, AFE_SWITCH_FIR, '-', aud_func);
}

kal_bool AFE_IsFIROn( kal_uint8 aud_func )
{
   return ((afe.fir_flag & (1<<aud_func)) != 0);
}
/*****************************************************************************
* FUNCTION
*  AFE_TurnMicrophoneOn
* DESCRIPTION
*   This function is to turn on the microphone of an audio function.
*
* PARAMETERS
*  aud_func - the audio function
* RETURNS
*  None
* CALLER
*  Task
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void AFE_TurnOnMicrophone( kal_uint8 aud_func )
{
   kal_uint32 savedMask;

   /// Disable interrupt to prevent race condition
   savedMask = SaveAndSetIRQMask();
   afe.mic_flag |= (1<<aud_func);
   RestoreIRQMask(savedMask);
#if !(defined(MT6235) || defined(MT6238))
   if(!afe.loopback)
      *AFE_VAGC_CON = HW_AGC_SETTING;
#endif

   afe.refresh = KAL_TRUE;

   ///Currently, when video recording, video LISR will call Media_Record.
   ///ASSERT(!kal_if_hisr());
   ///kal_trace(TRACE_STATE, AFE_SWITCH_MIC, '+', aud_func);
   L1Audio_Msg_AFE_TurnMIC( L1AUDIO_Str_onoff(1), L1AUDIO_Func_Name(aud_func) );
}

/*****************************************************************************
* FUNCTION
*  AFE_TurnOffMicrophone
* DESCRIPTION
*   This function is to turn off the microphone of an audio function.
*
* PARAMETERS
*  aud_func - the audio function
* RETURNS
*  None
* CALLER
*  Task
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void AFE_TurnOffMicrophone( kal_uint8 aud_func )
{
   kal_uint32 savedMask;

   /// Disable interrupt to prevent race condition
   savedMask = SaveAndSetIRQMask();
   afe.mic_flag &= ~(1<<aud_func);
#if !(defined(MT6235) || defined(MT6238))
   if( afe.mic_flag == 0 )
	   *AFE_VAGC_CON = 0;
#endif
   RestoreIRQMask(savedMask);

   afe.refresh = KAL_TRUE;

   ///Currently, when video recording, video LISR will call Media_Record.
   ///ASSERT(!kal_if_hisr());
   ///kal_trace(TRACE_STATE, AFE_SWITCH_MIC, '-', aud_func);
   L1Audio_Msg_AFE_TurnMIC( L1AUDIO_Str_onoff(0), L1AUDIO_Func_Name(aud_func) );
}

kal_bool AFE_IsMicrophoneOn( kal_uint8 aud_func )
{
   return ((afe.mic_flag & (1<<aud_func)) != 0);
}

/*****************************************************************************
* FUNCTION
*  AFE_MuteMicrophone
* DESCRIPTION
*   This function is to mute the microphone.
*
* PARAMETERS
*  mute - true : mute ; false : unmute ¡@¡@
* RETURNS
*  None
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void AFE_MuteMicrophone( kal_bool mute )
{
   afe.mic_mute = mute;

   afe.refresh = KAL_TRUE;
}

kal_bool AFE_IsMicrophoneMuted( void )
{
   return afe.mic_mute;
}

/*****************************************************************************
* FUNCTION
*  AFE_Mute
* DESCRIPTION
*   This function is to mute both microphone and speaker.
*
* PARAMETERS
*  mute - true : mute ; false : unmute ¡@¡@
* RETURNS
*  None
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void AFE_Mute( kal_bool mute )
{
   afe.mute = mute;
   
   afe.refresh = KAL_TRUE;
}

/*****************************************************************************
* FUNCTION
*  AFE_TurnOnExtAmplifier
*  AFE_TurnOffExtAmplifier
* DESCRIPTION
*   These two function are to turn on/off external amplifier individually
*****************************************************************************/
void AFE_TurnOnExtAmplifier( void )
{
   afe.gpio_lock = KAL_TRUE;
   AFE_SwitchExtAmplifier( true );
   afe.ext_op_on = KAL_TRUE;
}

void AFE_TurnOffExtAmplifier( void )
{
   AFE_SwitchExtAmplifier( false );
   afe.gpio_lock = KAL_FALSE;
   afe.ext_op_on = KAL_FALSE;
}


#if defined(G_SENSOR_SUPPORT)
//Huyanwei Add It For G Sensor 

extern void AFE_GSensor_SwitchExtAmplifier( char sw_on );

void AFE_GSensor_TurnOnExtAmplifier( void )
{
// afe.gpio_lock = KAL_TRUE;
   AFE_GSensor_SwitchExtAmplifier( true );
// afe.ext_op_on = KAL_TRUE;
}

void AFE_GSensor_TurnOffExtAmplifier( void )
{
   AFE_GSensor_SwitchExtAmplifier( false );
// afe.gpio_lock = KAL_FALSE;
// afe.ext_op_on = KAL_FALSE;
}


#endif

/*****************************************************************************
* FUNCTION
*  UpdateSideTone
*****************************************************************************/
static const kal_uint16 SideToneTable[] = {
   32767, 26027, 20674, 16422, 13044, 10361, 8230, 6537,       /* 2 dB per step */
    5193,  4125,  3276,  2602,  2066,  1641, 1304, 1035,
     822,   653,   519,   412,   327,   260,  206,  164
};

static void UpdateSidetone( kal_int8 vol )
{
   kal_int8 J;
   kal_uint32 R;

   if(afe.sidetone_disable || afe.sidetone_volume == 0) {
      *DP_SIDETONE_VOL = 0;
      return;
   }
   R = (kal_uint32)(afe.sidetone_volume & 0xF);
   vol = vol + 8 - (kal_int8)(afe.sidetone_volume >> 4);
   if( vol < 0 )
      vol = 0;
   J = ( vol == 0 )? 0: vol-1;
   *DP_SIDETONE_VOL = (kal_uint16)(((kal_uint32)SideToneTable[vol]*(16-R) + (kal_uint32)SideToneTable[J]*R) >> 4);
}

static void UpdateVGain( kal_uint8 aud_func )
{
   const kal_uint16 vol = afe.aud[aud_func].volume;
   const kal_uint16 amp_gain = (vol>>4);
#if defined(MT6235) || defined(MT6238)
   *AFE_VAG_CON = (kal_uint16)((amp_gain)|(amp_gain << 4));
   *AFE_VAGC_CON0 = ((kal_uint16)afe.mic_volume << 4) | (*AFE_VAGC_CON0 & 0xFC0E);//set Voice band uplink gain and diable AGC
   *AFE_VAGC_CON0 |= 0x1;                                                         //enable AGC
#else
   *AFE_VAG_CON = ((kal_uint16)afe.mic_volume << 8) | (kal_uint16)((amp_gain)|(amp_gain << 4));
#endif
   if( aud_func == L1SP_SPEECH ) 
      UpdateSidetone( (kal_int8)(vol >> 4) );   
   else
      *DP_SIDETONE_VOL = 0;
}

static void UpdateAGain( kal_uint8 aud_func )
{
   const kal_uint16 vol = afe.aud[aud_func].volume;
   const kal_uint16 amp_gain = (vol>>4);

   /// Preserve the ADC_COUPLE bit (0x0400) and AVCM_MODE bit (0x0800)
   *AFE_AAG_CON = (*AFE_AAG_CON & 0x0C00) | (kal_uint16)((amp_gain)|(amp_gain << 4));
   if( aud_func == L1SP_SPEECH )
      UpdateSidetone( (kal_int8)(vol >> 4) );
   else
      *DP_SIDETONE_VOL = 0;
}

static void _update_digital_gain_imp(kal_int16 aud_func)
{
   kal_uint16 digital_gain = afe.aud[aud_func].digital_gain;
   kal_uint32 level_gain;

   level_gain = ((uint32)afe.aud[aud_func].digital_gain_level * 0x8000) / 100;
   switch (aud_func) {
      /// Speech
      case L1SP_KEYTONE:
      case L1SP_TONE:
      case L1SP_SPEECH:
      case L1SP_SND_EFFECT:      
      case L1SP_VOICE:
         *DP_VOL_OUT_PCM = ((((kal_uint32)DG_DL_Speech * digital_gain) >> 15) * level_gain) >> 15;
         break;
      /// Audio (DAF, AAC, WMA, WAV), MIDI, multi-channel wave, tone
      case L1SP_AUDIO:
         *DP_DigiGain_Setting = ((((kal_uint32) DG_DAF * digital_gain) >> 15) * level_gain) >> 15;                  
         break;

      /// not really an audio function
      case L1SP_DAI:
         break;
      /// can't apply digital gain
      case L1SP_FM_RADIO:
         break;
      default:
         ASSERT(0);
   }
}

static void _update_digital_gain(kal_int16 v_lowest, kal_int16 a_lowest)
{
#if defined(__BT_SUPPORT__)
   if(AM_IsBluetoothOn()) {
      /// for the case of bluetooth use
      return;
   }
#endif   
   if (v_lowest >= 0) {
      if (a_lowest >= 0) {
         /// Voice Amp ON && Audio Amp ON
         _update_digital_gain_imp(v_lowest);
         _update_digital_gain_imp(a_lowest);
      } else {
         /// Voice Amp ON && Audio Amp OFF
         _update_digital_gain_imp(v_lowest);
      }
   } else if (a_lowest >= 0) {
      /// Voice Amp OFF && Audio Amp ON
      _update_digital_gain_imp(a_lowest);
   } else {
      /// Voice Amp OFF && Audio Amp OFF
      /// Restore the values to default value (for Bluetooth)
      *DP_VOL_OUT_PCM = DG_DL_Speech;
#if defined(EXT_DAC_SUPPORT)
      if(afe.ext_dac_aud_func == -1)     
#endif             
      *DP_DigiGain_Setting = DG_DAF;      
   }
}

/*****************************************************************************
* FUNCTION
*  UpdateVAPDN
*****************************************************************************/
static const kal_uint8 VAPDN_Tab[] = {
   0x00, 0x25, 0x26, 0x27, 0x38, 0x3D, 0x3E, 0x3F
};

static void UpdateVAPDN(kal_uint8 device, kal_uint16 vapdn_dc_couple_control)
{
   kal_uint16 val, old;
   DelayCmd dc;

   old = *AFE_VAPDN_CON;
   val = VAPDN_Tab[(device&3) + (( afe.mic_mute||afe.mic_flag==0 ||afe.mute)?0:4)] | ((afe.accessory_flag)? 0x20 : 0);
   /// Turn on Voice Amp-1 so that AU_OUT1_N supplies 1.4V DC if needed.
   val |= vapdn_dc_couple_control;
   if( old != val ) {
      if( val & 3 ) { /// Turn on speaker
         /// Turn off speaker first
         /// Turn on along with the turning on of voice DAC
         *AFE_VAPDN_CON = val & ~3;         
         dc.addr = AFE_VAPDN_CON;
         dc.val = val;
         RB_PUT( afe.regq, dc );
      }
      else { /// Turn off speaker
         if(old & 3)  
         {
            *AFE_VAPDN_CON = old & ~3; // turn off buffer first 
            dc.addr = AFE_VAPDN_CON;
            dc.val = val;               
            RB_PUT( afe.regq, dc );    // turn off DAC later       
         }
         else if(old & 4)  
         {
            dc.addr = AFE_VAPDN_CON;
            dc.val = val;               
            RB_PUT( afe.regq, dc );    // turn off DAC later               
         }
         else          
            *AFE_VAPDN_CON = val;
      }
   }
}

static void SearchSpkFlag( kal_int16 *v_lowest, kal_int16 *a_lowest )
{
   kal_int16 I, val;
   
   if(afe.mute)
   {      
      *v_lowest = -1; 
      *a_lowest = -1;  
      return;
   }   
   
   for( I = 15; I >= 0; I-- ) {
      if( afe.sp_flag & (1<<I) ) {
         val = (kal_uint16)afe.aud[I].out_dev;
         if( val & (L1SP_BUFFER_0|L1SP_BUFFER_1) )
            *v_lowest = I;
         if( val & L1SP_BUFFER_ST )
            *a_lowest = I;
      }
   }
   
   // move _update_digital_gain here for APM 
   _update_digital_gain(*v_lowest, *a_lowest); 
   kal_trace(TRACE_STATE, AFE_DIGI_GAIN, *DP_VOL_OUT_PCM, *DP_DigiGain_Setting);
   
   if( *a_lowest >= 0 )
      if( afe.aud[*a_lowest].volume == 0 || afe.aud[*a_lowest].mute == KAL_TRUE )
         *a_lowest = -1;
   if( *v_lowest >= 0 )
      if( afe.aud[*v_lowest].volume == 0 || afe.aud[*v_lowest].mute == KAL_TRUE )
         *v_lowest = -1;
}

void _apply_mic_setting_6227(kal_int16 a_lowest)
{
   /// MT6226/6227 (single die)
   if( afe.mic_src==L1SP_LNA_FMRR ) {                    /* FM Radio Playback/Recording Mode */
      *AFE_VAC_CON0 = (*AFE_VAC_CON0 & 0x003F) | 0x0900; /* Use built-in FM recording path */
   }
   else if( afe.mic_src==L1SP_LNA_1 ) {                  /* Headset Mode */
      *AFE_VAC_CON0 = (*AFE_VAC_CON0 & 0x003F) | 0x0880; /* Switch input source to headset microphone */
   }
   else {                                                /* Normal Mode */
      *AFE_VAC_CON0 = (*AFE_VAC_CON0 & 0x003F);          /* Switch input source to normal microphone */
   }
}

void _apply_mic_setting_c63216(kal_int16 a_lowest)
{
   /// MT6205, MT6218, MT6217, MT6219
   /// MT6228/6229 with C63216
   if( afe.mic_src==L1SP_LNA_1 ) {                       /* Headset Mode */
      *AFE_VAC_CON0 |= 0x0480;                           /* Switch input source to headset microphone */
      *AFE_VAC_CON1 |= 0x0040;                           /* Switch on resister string */
   }
   else {                                                /* Normal Mode */
      *AFE_VAC_CON0 &= ~0x0480;                          /* Switch input source to normal microphone */
      *AFE_VAC_CON1 &= ~0x0040;                          /* Switch off resister string */
   }
}

void _apply_mic_setting_d63216(kal_int16 a_lowest)
{
   /// MT6228/6229 with Analog Die D63216
   /// AFE_VAC_CON0::VCFG definition is different from previous version
   if( afe.mic_src==L1SP_LNA_FMRR ) {                    /* FM Radio Playback/Recording Mode */
      *AFE_VAC_CON0 = (*AFE_VAC_CON0 & 0x307F) | 0x0900; /* Use built-in FM recording path */
      *AFE_VAC_CON1 |= 0x0040;
      if (KAL_TRUE == AFE_DC_Couple_Mode) {
         /// Disable ADC_COUPLE
         *AFE_AAG_CON &= ~0x400;
      }
   }
   else if( afe.mic_src==L1SP_LNA_1 ) {                  /* Headset Mode */
      *AFE_VAC_CON0 = (*AFE_VAC_CON0 & 0x307F) | 0x0880; /* Switch input source to headset microphone */
      *AFE_VAC_CON1 |= 0x0040;
      if (KAL_TRUE == AFE_DC_Couple_Mode) {
         /// Enable ADC_COUPLE
         *AFE_AAG_CON |= 0x400;
         /// Enable 0x800 for Backward Compatible
         ///*AFE_AAG_CON |= 0x800;
      }
   }
   else {                                                /* Normal Mode */
      *AFE_VAC_CON0 = (*AFE_VAC_CON0 & 0x307F);          /* Switch input source to normal microphone */
      *AFE_VAC_CON1 &= ~0x0040;
      if (KAL_TRUE == AFE_DC_Couple_Mode) {
         /// Disable ADC_COUPLE
         *AFE_AAG_CON &= ~0x400;
      }
   }
}

static void _apply_mic_setting(kal_int16 a_lowest)
{
   /// AFE_VAC_CON1::VRESSW is used to output 1/2Vdd when voice buffer 1 power down
   /// so that when it is power on, the voltage will not suddenly jump (for depop)
#if defined(MT6228) || defined(MT6229) || defined(MT6230) || defined(MT6225) || defined(MT6268T) || defined(MT6223) || defined(MT6223P) || defined(MT6235) || defined(MT6238)
   if (0x8C01 == *ACIF_AC_HW_VER) {
      /// C63216
      _apply_mic_setting_c63216(a_lowest);
   } else {
      _apply_mic_setting_d63216(a_lowest);
   }
#elif defined(MT6226) || defined(MT6226D) || defined(MT6226M) || defined(MT6227) || defined(MT6227D)  /* for MT6226/27, buf1 is removed, internal MUX for FMRR is added */
   _apply_mic_setting_6227(a_lowest);
#else
   /// MT6205/6217/6218/6219
   _apply_mic_setting_c63216(a_lowest);
#endif
}

/* ========================================================================= */
/*   AFE Event Handler                                                       */
/*   This function runs under the context of L1Audio Task                    */
/* ========================================================================= */
static void AFE_Event_Handler( void *data )
{
   kal_uint16 val;
   DelayCmd dc;
   /// In DC Couple Mode, AU_OUT1_N should supply 1.4V DC whenever
   /// the related device is turned on.
   /// afe_vapdn_con_dc_couple_bits is set to turn on both
   /// VPDN_BIAS and VPDN_OUT1 of AFE_VAPDN_CON.
   kal_uint16 vapdn_dc_couple_control = 0;

   ASSERT(!kal_if_hisr());

   {
      kal_int16 v_lowest = -1, a_lowest = -1;

      if( afe.sp_flag ) {
         /// v_lowest: the highest priority aud function which outputs through
         ///           Voice Amp-0 or Voice Amp-1
         /// a_lowest: the highest priority aud function which outputs through
         ///           Audio Amp
         SearchSpkFlag( &v_lowest, &a_lowest );
      }

      if (KAL_TRUE == AFE_DC_Couple_Mode) {
         if ( ((KAL_FALSE == afe.mic_mute) && (afe.mic_flag!=0) && (!afe.mute)&& (L1SP_LNA_1 == afe.mic_src)) ||
              (a_lowest >= 0) ) {
            /// turn on VPDN_BIAS and VPDN_OUT1
            vapdn_dc_couple_control = 0x22;
         }
      }

      L1Audio_Msg_AFE_SpkSelect( v_lowest, a_lowest, afe.fir_flag, afe.mic_flag, afe.mic_volume );

   #if defined(EXT_DAC_SUPPORT)      
      if(a_lowest != -1 && !afe.ext_dac_mute && (afe.aud[a_lowest].out_dev & (L1SP_EXT_DAC_BUF0 | L1SP_EXT_DAC_BUF1)))
      {
         if(afe.ext_dac_aud_func != a_lowest)
         {
            kal_uint8 out_spk;  
            
            afe.ext_dac_aud_func = a_lowest;                   
            out_spk = afe.aud[a_lowest].out_dev & (L1SP_EXT_DAC_BUF0|L1SP_EXT_DAC_BUF1);       
            
            switch((SND_SRC_MAP>>a_lowest*2)&3) 
            {            
               case SRC_AUDIO_DAC:
                  EXT_DAC_SetPlaybackFreq(afe.ext_dac_freq);
                  EXT_DAC_TurnOnSpeaker(EXT_DAC_I2S , out_spk );    
                  AFE_TurnOnEDI(1, L1SP_EXT_DAC_I2S_BCLK_SCALE >> 1); 
                  EXT_DAC_SetVolume(out_spk , afe.ext_dac_aud_vol);
                  afe.ext_dac_i2s_on = KAL_TRUE;
                  if(afe.ext_dac_add_st)
                     a_lowest = -1;  // Turn Off Audio Stereo Buffer When using EXT_DAC only    
                  break;
               case SRC_VOICE_DAC:   
               case SRC_EXT_INPUT:
                  EXT_DAC_TurnOnSpeaker(EXT_DAC_LINEIN , out_spk); 
                  EXT_DAC_FixedLineInGain(out_spk);
                  break;
            }
         }
         else 
         {
            if(((SND_SRC_MAP>>a_lowest*2)&3) == SRC_AUDIO_DAC && afe.ext_dac_add_st)
               a_lowest = -1;
         }                                             
         if(afe.ext_dac_aud_func == L1SP_AUDIO)    
            *DP_DigiGain_Setting = ((kal_uint32) DG_DAF * afe.ext_dac_level_gain) >> 15;                                        
      }  
      else 
      {
         if(afe.ext_dac_aud_func != -1)
         {
            kal_uint8 out_spk;  
            out_spk = afe.aud[afe.ext_dac_aud_func].out_dev & (L1SP_EXT_DAC_BUF0|L1SP_EXT_DAC_BUF1);
            afe.ext_dac_aud_func = -1; 
            if(afe.ext_dac_i2s_on)
            {           
               AFE_TurnOffEDI(); 
               afe.ext_dac_i2s_on = KAL_FALSE;             
            }                        
            EXT_DAC_TurnOffSpeaker(out_spk);
         }   
      }
      
   #endif    
      if( v_lowest >= 0 ) {
         /// If there exists an aud function (v_lowest) which wants to output through
         /// Voice Amp-0 or Voice Amp-1
         UpdateVGain( v_lowest );
         /// Clear VBUF1SEL bit-fields: voice buffer 1 input selection
         val = *AFE_VAC_CON1 & 0xFFE3;
         switch((SND_SRC_MAP>>v_lowest*2)&3) {
            /// determine the source for the aud function v_lowest
            case SRC_VOICE_DAC:
               if( afe.fir_flag & (1<<v_lowest) )
                  *DP_AUDIO_PAR |= 3;

#if (!defined(MT6219)&&!defined(MT6205)&&!defined(MT6205B)&&!defined(MT6219B)&&!defined(MT6217))
               else if (afe.toneLoopbackRec){
                  // don't disable input/output filtering
               }
#endif
               else
                  *DP_AUDIO_PAR &= ~3;
#if !(defined(MT6235) || defined(MT6238))//should not modify bit [2]
               *AFE_VAC_CON1 = val | 0x04; /// from voice DAC output
#endif
               /// Voice-Amp1 does not need input from audio DAC,
               /// also Audio Amp is not used, turn them off.
               if( a_lowest < 0 )
               {
               #if defined(MT6223) || defined(MT6223P) 
                  kal_uint16 old; 
                  old = *AFE_AAPDN_CON; 
                  if((old & 0x3) && (old & 0xC))  // buffer and DAC both on 
                  {
                     *AFE_AAPDN_CON = old & ~0x3; // turn off buffer first       
                     dc.addr = AFE_AAPDN_CON;
                     dc.val = AAPDN_POWER_DOWN;   
                     RB_PUT( afe.regq, dc );      // then turn off DAC 
                  }
                  else 
               #endif    
                  *AFE_AAPDN_CON = AAPDN_POWER_DOWN;                                    
               }   
               break;
            case SRC_AUDIO_DAC:
               /// Stereo-to-Mono will be automatically done by the MUX of Voice Amp-1
               *AFE_VAC_CON1 = val | 0x10; /// from audio DAC output
               *AFE_AAPDN_CON  = AAPDN_BIAS_DAC_ON;
               break;
            case SRC_EXT_INPUT:
               /// Stereo-to-Mono will be automatically done by the MUX of Voice Amp-1
               *AFE_VAC_CON1 = val | 0x08; /// from external FM radio input
               /// Voice-Amp1 does not need input from audio DAC,
               /// also Audio Amp is not used, turn them off.
               if( a_lowest < 0 )
               {
               #if defined(MT6223) || defined(MT6223P) 
                  kal_uint16 old; 
                  old = *AFE_AAPDN_CON; 
                  if((old & 0x3) && (old & 0xC))  // buffer and DAC both on 
                  {
                     *AFE_AAPDN_CON = old & ~0x3; // turn off buffer first       
                     dc.addr = AFE_AAPDN_CON;
                     dc.val = AAPDN_POWER_DOWN;   
                     RB_PUT( afe.regq, dc );      // then turn off DAC 
                  }
                  else 
               #endif    
                  *AFE_AAPDN_CON = AAPDN_POWER_DOWN;                                    
               }   
               break;
         }
         UpdateVAPDN(afe.aud[v_lowest].out_dev, vapdn_dc_couple_control);

         if( a_lowest >= 0 ) {
            UpdateAGain( a_lowest );
            /// Clear ABUFSEL[L|R] bit-fields:
            /// audio buffer [L|R]-channel input selection
            val = *AFE_AAC_CON & 0xF81F;
            switch((SND_SRC_MAP>>a_lowest*2)&3) {
               /// determine the source for the aud function a_lowest
               case SRC_VOICE_DAC:
                  if( afe.fir_flag & (1<<a_lowest) )
                     *DP_AUDIO_PAR |= 3;
#if (!defined(MT6219)&&!defined(MT6205)&&!defined(MT6205B)&&!defined(MT6219B)&&!defined(MT6217))
                  else if (afe.toneLoopbackRec){
                  // don't disable input/output filtering
                  }
#endif
                  else
                     *DP_AUDIO_PAR &= ~3;
                  *AFE_AAC_CON = val | 0x240;
                  break;
               case SRC_AUDIO_DAC:
#if defined(MT6235) || defined(MT6238)
                  *AFE_AAC_CON = val | 0x120;
                  if((afe.aud[a_lowest].out_dev&L1SP_STEREO2MONO))
                     *AFE_AMCU_CON1 |= 0x4000;
                  else
                     *AFE_AMCU_CON1 &= ~0x4000;
#else
                  *AFE_AAC_CON = val | ((afe.aud[a_lowest].out_dev&L1SP_STEREO2MONO)?0:0x120);
#endif
                  break;
               case SRC_EXT_INPUT:
                  *AFE_AAC_CON = val | ((afe.aud[a_lowest].out_dev&L1SP_STEREO2MONO)?0x480:0x5A0);
                  break;
            }
            *AFE_AAPDN_CON=( a_lowest >= 0 )?AAPDN_ALL_ON:AAPDN_BIAS_DAC_ON;
         }
         kal_trace(TRACE_STATE, AFE_GAIN, *AFE_VAG_CON, *AFE_AAG_CON, *DP_SIDETONE_VOL);
      }
      else if( a_lowest >= 0 ) {
         /// If there is no aud function which wants to output through
         /// Voice Amp-0 or Voice Amp-1. But there is aud function which
         /// wants to output through Audio Amp.
         UpdateAGain( a_lowest );
         /// Clear ABUFSEL[L|R] bit-fields:
         /// audio buffer [L|R]-channel input selection
         val = *AFE_AAC_CON & 0xF81F;
         switch((SND_SRC_MAP>>a_lowest*2)&3) {
            case SRC_VOICE_DAC:
               if( afe.fir_flag & (1<<a_lowest) )
                  *DP_AUDIO_PAR |= 3;
#if (!defined(MT6219)&&!defined(MT6205)&&!defined(MT6205B)&&!defined(MT6219B)&&!defined(MT6217))
               else if (afe.toneLoopbackRec){
                  // don't disable input/output filtering
               }
#endif
               else
                  *DP_AUDIO_PAR &= ~3;
               *AFE_AAC_CON = val | 0x240;
               //// turn on only BIAS & DAC
               *AFE_VAPDN_CON = 0x24 | vapdn_dc_couple_control;
               break;
            case SRC_AUDIO_DAC:
#if defined(MT6235) || defined(MT6238)
               *AFE_AAC_CON = val | 0x120;
               // for MT6235/38, Stereo-to-mono is controlled by AFE_AMCU_CON1 bit 14
               if((afe.aud[a_lowest].out_dev&L1SP_STEREO2MONO)) 
                  *AFE_AMCU_CON1 |= 0x4000;
               else
                  *AFE_AMCU_CON1 &= ~0x4000;
#else
               *AFE_AAC_CON = val | ((afe.aud[a_lowest].out_dev&L1SP_STEREO2MONO)?0:0x120);
#endif
               *AFE_VAPDN_CON = (afe.accessory_flag)?0x20:0  | vapdn_dc_couple_control;
               break;
            case SRC_EXT_INPUT:
               *AFE_AAC_CON = val | ((afe.aud[a_lowest].out_dev&L1SP_STEREO2MONO)?0x480:0x5A0);
#if defined(MT6226) || defined(MT6226D) || defined(MT6226M) || defined(MT6227) || defined(MT6227D) || defined(MT6228) || defined(MT6225) || defined(MT6229) || defined(MT6230) || defined(MT6268T) || defined(MT6223) || defined(MT6223P) || defined(MT6235) || defined(MT6238)
               /* FOR MT6226/27/28, the mic LNA need to be turned on when FM playback */
               *AFE_VAPDN_CON = 0x30 | vapdn_dc_couple_control;
               /* make mic_gain be updated for reducing the pop-up noise when enabling FM recording */
               *AFE_VAG_CON = (FM_RADIO_RECORDING_VOLUME << 8) | (*AFE_VAG_CON & 0x00FF);
#else
               *AFE_VAPDN_CON = (afe.accessory_flag)?0x20:0 | vapdn_dc_couple_control;
#endif
               break;
         }

         /// The turn-on of the audio amplifier should be delayed because the DAC needs some time to stabilize         
         dc.addr = AFE_AAPDN_CON;
         dc.val = AAPDN_ALL_ON;
         RB_PUT( afe.regq, dc );

         if( afe.mic_flag && !afe.mic_mute && !afe.mute) {
            if( afe.mic_src==L1SP_LNA_FMRR ) /* FM Radio Recording */
               *AFE_VAG_CON = (FM_RADIO_RECORDING_VOLUME << 8) | (*AFE_VAG_CON & 0x00FF);
            else{  /* Normal recording */
#if defined(MT6235) || defined(MT6238)
               *AFE_VAGC_CON0 = ((kal_uint16)afe.mic_volume << 4) | (*AFE_VAGC_CON0 & 0xFC0E);//set Voice band uplink gain and diable AGC
               *AFE_VAGC_CON0 |= 0x1;                                                         //enable AGC
#else
               *AFE_VAG_CON = ((kal_uint16)afe.mic_volume << 8) | (*AFE_VAG_CON & 0x00FF);
#endif
            }
            *AFE_VAPDN_CON |= 0x38 | vapdn_dc_couple_control;
         }
         kal_trace(TRACE_STATE, AFE_GAIN, *AFE_VAG_CON, *AFE_AAG_CON, *DP_SIDETONE_VOL);
      }
      else {
         /// If there is no aud function which wants to output through
         /// Voice Amp-0 or Voice Amp-1 or Audio Amp.
         /// Update MIC volume here for the scenario that microphone is turned on with no speaker on 
         if( afe.mic_flag && !afe.mic_mute && !afe.mute) {
#if defined(MT6235) || defined(MT6238)
            *AFE_VAGC_CON0 = ((kal_uint16)afe.mic_volume << 4) | (*AFE_VAGC_CON0 & 0xFC0E);//set Voice band uplink gain and diable AGC
            *AFE_VAGC_CON0 |= 0x1;                                                         //enable AGC
#else
            *AFE_VAG_CON = ((kal_uint16)afe.mic_volume << 8) | (*AFE_VAG_CON & 0x00FF);
#endif
         }
         UpdateVAPDN( 0, vapdn_dc_couple_control );
         #if defined(MT6223) || defined(MT6223P)
         {               
            kal_uint16 old; 
            old = *AFE_AAPDN_CON; 
            if((old & 0x3) && (old & 0xC))  // buffer and DAC both on 
            {
               *AFE_AAPDN_CON = old & ~0x3; // turn off buffer first       
               dc.addr = AFE_AAPDN_CON;
               dc.val = AAPDN_POWER_DOWN;   
               RB_PUT( afe.regq, dc );      // then turn off DAC 
            }
            else
               *AFE_AAPDN_CON = AAPDN_POWER_DOWN; 
         }                
         #else             
         *AFE_AAPDN_CON  = AAPDN_POWER_DOWN;                                            
         #endif
      }

      /// Switch external amplifier
      if( !afe.gpio_lock ) {
         if( ( (a_lowest >= 0) && (afe.aud[a_lowest].out_dev & L1SP_BUFFER_EXT) ) ||
            ( (v_lowest >= 0) && (afe.aud[v_lowest].out_dev & L1SP_BUFFER_EXT) ) ) {
            /// Turn on the external amplifier                        
            if (Ext_op_on_delay == 0) {
               AFE_SwitchExtAmplifier( true );
               afe.ext_op_on = KAL_TRUE;               
               /// Reset the ext_op_delay timer to indicate the completion of current operation
               afe.ext_op_delay = 0;
            } else {
               /// The latest command will replace the un-executed command
               afe.ext_op_delay = (int16)Ext_op_on_delay;
            }
         } else {
            /// Turn off the external amplifier                        
            if (Ext_op_off_delay == 0) {
               AFE_SwitchExtAmplifier( false );
               afe.ext_op_on = KAL_FALSE;
               /// Reset the ext_op_delay timer to indicate the completion of current operation
               afe.ext_op_delay = 0;
            } else {
               /// The latest command will replace the un-executed command
               afe.ext_op_delay = -(int16)Ext_op_off_delay;
            }
         }
      }

#if defined(MT6226) || defined(MT6226M) || defined(MT6227) /* for fixing a MT6226/27 analog circuit bug */
      if( INT_ecoVersion()==ECO_E1 ) {
         if( *AFE_VAPDN_CON & 0x20 )
            *AFE_VAC_CON1 &= ~0x1000;
         else
            *AFE_VAC_CON1 |= 0x1000;
      }
#endif

      _apply_mic_setting(a_lowest);
   }
}

/* ========================================================================= */
/*   AFE Manager                                                             */
/*   This function runs under the context of L1 ISR                          */
/* ========================================================================= */
void AFE_Manager( void )
{   
   DelayCmd dc;

   if( afe.ext_op_delay != 0 ) {
      if( afe.ext_op_delay > 0 ) {
         if( --afe.ext_op_delay == 0 ) {
            AFE_SwitchExtAmplifier( true );
            afe.ext_op_on = KAL_TRUE;
         }
      }
      else { /* afe.ext_op_delay < 0 */
         if( ++afe.ext_op_delay == 0 ) {
            AFE_SwitchExtAmplifier( false );
            afe.ext_op_on = KAL_FALSE;
         }
      }
   }

   if( afe.refresh ) 
   {
      afe.refresh = KAL_FALSE;
      L1Audio_LSetEvent(afe.aud_id, NULL);
   }   

   if( !RB_EMPTY( afe.regq ) ) {
      RB_GET( afe.regq, dc );
      *dc.addr = dc.val;
   }
   
   if(afe.v8k_off_request)
   {
      if((*AFE_VAPDN_CON & 0x1F)== 0)
      {         
         *PDN_SET2       = PDN_CON2_VAFE;
         *AFE_VMCU_CON  &= ~0x0001;
         L1Audio_Msg_AFE_Switch( L1AUDIO_Str_onoff(0), AFE_Switch_Name(0) );
         afe.v8k_off_request = KAL_FALSE;
      }            
   }
   
   if(afe.aClk_off_request)
   {
      if(*AFE_AAPDN_CON == 0)
      {
         *PDN_SET2       = PDN_CON2_AAFE;
         *AFE_AMCU_CON0 &= ~0x0001;     
         afe.aClk_off_request = KAL_FALSE;
      }            
   }
   
}   

/*****************************************************************************
* FUNCTION
*  AFE_TurnOnMicBias , AFE_TurnOffMicBias
*       : Add for accessory detection use
* CALLER
*  AUX_EINT_HISR
*****************************************************************************/
kal_uint8 AFE_TurnOnMicBias( void )
{
   kal_uint32 savedMask;

   afe.accessory_flag = KAL_TRUE;

   savedMask = SaveAndSetIRQMask();
   *AFE_VAPDN_CON |= 0x20;
#if defined(MT6226) || defined(MT6226D) || defined(MT6226M) || defined(MT6227) || defined(MT6227D) 	/* for fixing a MT6226/27 analog circuit bug */
   *AFE_VAC_CON1 &= ~0x1000;
#endif
   RestoreIRQMask(savedMask);

   afe.refresh = KAL_TRUE;

   L1Audio_Msg_AFE_Switch( L1AUDIO_Str_onoff(1), AFE_Switch_Name(4) );

   return (afe.mic_src==L1SP_LNA_1);
}

void AFE_TurnOffMicBias(void)
{
   afe.accessory_flag = KAL_FALSE;

   afe.refresh = KAL_TRUE;

   L1Audio_Msg_AFE_Switch( L1AUDIO_Str_onoff(0), AFE_Switch_Name(4) );
}

kal_bool AFE_IsAudioLoudSpk( void )
{
   if(afe.aud[L1SP_AUDIO].out_dev & L1SP_BUFFER_EXT)
      return KAL_TRUE;
   else 
      return KAL_FALSE;        
}

kal_uint16 AFE_GetDigiGain()
{
   kal_uint16 gain;
   
   if( AM_IsAudioPlaybackOn() != -1)
      gain = *DP_DigiGain_Setting;
   else{
      gain = *DP_VOL_OUT_PCM;
      gain = ( gain >= 0x1000 )? 0x7FFF : (gain << 3);
   }
   return gain;
}

const int16 AGC_DSP_Parameters[20]={
 1,   4, -14, -12, 1, 1024, 1,  800, -14, -10, 
 4, 511,  -4,   1, 5,    1, 2, 2047,  -9,  -6
};

/*****************************************************************************
* FUNCTION
*  AFE_Init
* DESCRIPTION
*   This function is to initialize the AFE module.
*
* PARAMETERS
*  None
* RETURNS
*  None
* CALLER
*  L1Audio_Task, L1Audio_ResetDevice
* GLOBALS AFFECTED
*  None
*****************************************************************************/
void AFE_Init( void )
{
   static kal_bool afe_initialized = KAL_FALSE;
   int I;

   RB_INIT( afe.regq );

   afe.refresh          = KAL_FALSE;
   afe.mic_src          = 0;
   afe.sidetone_volume  = 127;
   afe.sp_flag          = 0;
   afe.fir_flag         = 0;
   afe.mic_flag         = 0;
   afe.mic_volume       = 7;
   afe.mic_mute         = KAL_FALSE;
   afe.sidetone_disable = KAL_FALSE;
   afe.accessory_flag   = KAL_FALSE;
   afe.ext_op_on        = KAL_FALSE;
   afe.ext_op_delay     = 0;
   afe.mute             = KAL_FALSE;
   afe.loopback         = KAL_FALSE;
#if defined(EXT_DAC_SUPPORT)   
   afe.ext_dac_i2s_on   = KAL_FALSE;
   afe.ext_dac_add_st   = KAL_FALSE;
   afe.ext_dac_aud_func = -1;
   afe.ext_dac_level_gain  = 0x8000;
   EXT_DAC_Init();   
#endif       
   for( I = 0; I < L1SP_MAX_AUDIO; I++ ) {
      afe.aud[I].out_dev      = 0;
      afe.aud[I].volume       = 0x77;
      afe.aud[I].digital_gain = 0x8000;  // (in 1.15 fixed-point) 0 dB
      afe.aud[I].digital_gain_index = 0;
      afe.aud[I].digital_gain_level = 100;
      afe.aud[I].mute         = KAL_FALSE;
   }

   *DP_AUDIO_PAR     |= 0x40;    /* enable side-tone filter */
   *DP_SIDETONE_VOL  = 0;
   *DP_VOL_IN_PCM    = DG_Microphone;
   *DP_VOL_OUT_PCM   = DG_DL_Speech;
   *DP_DigiGain_Setting = DG_DAF;;

   *AFE_VMCU_CON      = 0;
   *AFE_VAGC_CON      = 0;
   *AFE_VAPDN_CON     = 0;
   *AFE_VAG_CON       = 0x777;
#if defined(MT6226) || defined(MT6226M) || defined(MT6227) /* for fixing a MT6226/27 analog circuit bug */
   *AFE_VAC_CON1      = (INT_ecoVersion()==ECO_E1)? 0x1084 : 0x84;
#elif defined(MT6235) || defined(MT6238)
   *AFE_VAC_CON1      = 0xa4; // VGBOOT set as 1x, VDIFF_BIAS set as differentail (MT6238E1)
#else
   *AFE_VAC_CON1      = 0x84;
#endif
   *AFE_AMCU_CON0     = 0;
#if defined(MT6235) || defined(MT6238)
   *AFE_AMCU_CON1     = 0x1100;       // enable SRC and SEL_IDWA
#else
   *AFE_AMCU_CON1     = 0;
#endif
#if defined(MT6238)   // only MT6238E1
   *AFE_AAC_NEW       = 0x0002;
#endif
   *AFE_AAPDN_CON     = 0;
   *AFE_AAC_CON       = 0x1120;
   *AFE_AAG_CON       = 0x77;

   *AFE_VDB_CON       = 0;
   *AFE_VLB_CON       &= ~0xF7;

#if defined(MT6228) || defined(MT6225) || defined(MT6229) || defined(MT6230) || defined(MT6268T) || defined(MT6223) || defined(MT6223P) || defined(MT6235) || defined(MT6238)
	/* set EQ cofficient*/
	*AFE_EQCOEF        = 32767;
   for( I = 1; I < 45; I++ )
      *(AFE_EQCOEF+2*I) = 0;
#endif
#if defined(MT6223) || defined(MT6223P)
   *AFE_AMCU_CON1 |= 0x100; //audio dither
   *AFE_VAC_DCON1 |= 0x1;   //speech dither
   //for MT6223, Add more dither to supress harmonic when small signal.
   //Tradeoff is a little noise flow increasement
#endif

//AGC configuration
#if defined(MT6235) || defined(MT6238)
   *AFE_VMCU_CON1 = 0x0287; // bit 0~2 are dither (enable for MT6238E1)
   *AFE_VAGC_CON1 = 0x2CC8;
   *AFE_VAGC_CON2 = 0xA4B5;
   *AFE_VAGC_CON3 = 0x2DD5;
   *AFE_VAGC_CON4 = 0x1018;
   *AFE_VAGC_CON5 = 0x3478;
   *AFE_VAGC_CON6 = 0x40FD;
   *AFE_VAGC_CON0 = 0x0286;
   *DP2_AGC_CTRL  = 0x2B;
   {
      volatile kal_uint16 *addr;
      addr = DSP2_DM_ADDR( DM_AGC_PARAMETER_PAGE, DM_AGC_PARAMETER_ADDR );
      for ( I = 0 ; I < 20 ; I++ )
         *addr++ = AGC_DSP_Parameters[I];
   }
#endif

   /// Set AFE_VAC_CON0::VDSEND (external circuit dependent) and AFE_VMCU_CON1
   AFE_Initialize();
   /// Set AFE_VAC_CON0::VCALI (chip dependent) and AFE_VMCU_CON1
   Set_AFE_VAC_CON0_VCALI();

   if (KAL_FALSE == afe_initialized) {
      afe.aud_id = L1Audio_GetAudioID();
      /// make sure AFE_Manager has the highest priority in the event group
      ASSERT(0 == afe.aud_id);
      L1Audio_SetEventHandler( afe.aud_id, AFE_Event_Handler );      
      afe_initialized = KAL_TRUE;      
   }

#if UNIT_TEST_AFE2
   {
      void afe2_unit_test( void );
      afe2_unit_test();
   }
#endif
   afe.v8k_off_request = KAL_FALSE;
   afe.aClk_off_request = KAL_FALSE;

#if (!defined(MT6219)&&!defined(MT6205)&&!defined(MT6205B)&&!defined(MT6219B)&&!defined(MT6217))
   afe.toneLoopbackRec = KAL_FALSE;
#endif
}



#if UNIT_TEST_AFE2
kal_uint16 digital_gain_ut[129];
float digital_gain_ut_diff[128];
kal_uint16 get_digital_gain(kal_int8 index)
{
   AFE_SetOutputVolume(0, 0, index);
   return afe.aud[0].digital_gain;
}
void afe2_unit_test( void )
{
   kal_int8 digital_gain_index;

   for(digital_gain_index=-128; digital_gain_index<=0; digital_gain_index++) {
      digital_gain_ut[digital_gain_index+128] = get_digital_gain(digital_gain_index);
   }

   /// python cmd: 20 * math.log10(0x8000/21.0) = 63.86dB
   ASSERT(digital_gain_ut[0] == 21);
   ASSERT(digital_gain_ut[128] == 0x8000);

   for(digital_gain_index=-128; digital_gain_index<=-1; digital_gain_index++) {
      digital_gain_ut_diff[digital_gain_index+128] =
         digital_gain_ut[digital_gain_index+128+1] * 1.0F /
         digital_gain_ut[digital_gain_index+128];
      /// perfect value is math.pow(10.0, 0.5/20.0) = 1.05925
      ASSERT(digital_gain_ut_diff[digital_gain_index+128] >= 1.035F);
      ASSERT(digital_gain_ut_diff[digital_gain_index+128] <= 1.084F);
   }

   /// shall assert here
   get_digital_gain(1);
}
#endif


void AFE_SetHardwareMute(bool mute)
{
   if(mute) 
   {
#if defined(EXT_DAC_SUPPORT)
      afe.ext_dac_mute = true;
      afe.refresh = KAL_TRUE;       
#endif       
      *AFE_AMCU_CON1 |= 0x0C;
      kal_sleep_task(30);            
   }
   else
   { 
#if defined(EXT_DAC_SUPPORT)      
      afe.ext_dac_mute = false;
      afe.refresh = KAL_TRUE; 
#endif           
      *AFE_AMCU_CON1 &= ~0x0C;            
   }       
}


#else 
// empty function for MT6205B  
void AFE_SetLevelVolume(kal_uint8 aud_func, kal_uint8 MaxAnalogGain, kal_uint8 step, kal_uint8 level)
{  
}   
#endif /* !defined(MT6205B) */
