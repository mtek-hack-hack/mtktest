/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 *  History.c
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!! 
 *==============================================================================
 *******************************************************************************/

/**
 * Copyright Notice
 * ?2002 - 2003, Pixtel Communications, Inc., 1489 43rd Ave. W.,
 * Vancouver, B.C. V6M 4K8 Canada. All Rights Reserved.
 *  (It is illegal to remove this copyright notice from this software or any
 *  portion of it)
 */

/**************************************************************

   FILENAME : History.c

   PURPOSE     : Implementation of Main LCD history stack

   REMARKS     : nil

   AUTHOR      : Manish

   DATE     : Aug' 28, 2002

**************************************************************/

#include "MMI_features.h"
#include "stdC.h"
#include "L4Dr.h"
#include "MMIDataType.h"
#include "GlobalConstants.h"
#include "CustMenuRes.h"
#include "FrameworkGprot.h"
#include "FrameworkProt.h"
#include "DebugInitDef.h"
#include "Unicodexdcl.h"
#include "MMI_trc.h"
#include "gdi_include.h"        /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */
#include "wgui_categories_util.h"       /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */
#include "wgui_draw_manager.h"
#include "ProfilingEngine.h"
#include "SimDetectionGprot.h"

typedef enum
{
    MMI_HIST_SMALLSCREEN_NONE,
    MMI_HIST_SMALLSCREEN_ACTIVE,
    MMI_HIST_SMALLSCREEN_ACTIVE_IN_EXIT_FUNC,
    
    /* add the enum value above here */
    MMI_HIST_SMALLSCREEN_END
}mmi_hist_smallscreen_state_enum;


/* 
 *   Extern Variables 
 */
pBOOL IsBackHistory = FALSE;
MMI_BOOL  mmi_is_orderly_exit_screen = MMI_FALSE;

/* 
 *   Local Variables 
 */
static pBOOL CheckMainLCDHistoryBack = FALSE;
static historyCallback historyCBHandler[MAX_HISTORY];
static historyNode historyData[MAX_HISTORY];    /* array of history data */
static S16 currHistoryIndex = -1;
static MMI_BOOL bBackHistoryFlag = MMI_FALSE;
static MMI_BOOL bDinitHistoryFlag = MMI_FALSE;

/* static U8 is_del_cb_found = MMI_FALSE; // gilbert --- for modifying decrement() */

/* 
 *   Extern Function 
 */

/* 
 *   Local Functions 
 */
static void ExecutePopHistory(void);
static U8 SearchDelScrnIDCallbackHandler(U16 ScrnID, U16 *found_idx);
static U8 ExecTopScrnCallbackHandler(void);
static U8 ExecHistoryScrnCallBackHandle(U16 HistoryIndex);
static void mmi_free_history_buffer(S16 id);
static S16 increment(void);
static U8 decrement(void);
static S16 searched_history_node(S16 first_index, U16 scrn_id);

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
static S32 small_history_node = 0;

/* static S32 check_for_small_history_node=0; */
static mmi_hist_smallscreen_state_enum redrawing_old_screens = 0;

static S32 no_small_screen = 0;
static S32 small_screen_enabled = 0;

#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 


#define NEW_DEL_API
__inline static U32 DeleteHistoryInt(U16 startScrId, U8 bIncStart, U16 count, U16 endScrId, U8 bIncEnd);



/*****************************************************************************
 * FUNCTION
 *  mmi_free_history_buffer
 * DESCRIPTION
 *  Free history GUI buffer and Input buffer
 *  
 * PARAMETERS
 *  id         [IN]  Index of history node which want to free. 
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_free_history_buffer(S16 id)
{
    if ((id >= 0) && ((id <= currHistoryIndex)||((0 == id)&&(currHistoryIndex == -1))))
    {
        if (historyData[id].guiBuffer)
        {
            OslMfree(historyData[id].guiBuffer);
            historyData[id].guiBuffer = NULL;
        }
        if (historyData[id].inputBuffer)
        {
            if (historyData[id].mfreeFuncPtr)
            {
                historyData[id].mfreeFuncPtr(historyData[id].inputBuffer);
            }
            else
            {
                OslMfree(historyData[id].inputBuffer);
            }
            historyData[id].inputBuffer = NULL;
        }
    }
}



/*****************************************************************************
 * FUNCTION
 *  increment
 * DESCRIPTION
 *  increment the global currHistoryIndex
 *  
 *  increment the global currHistoryIndex
 * PARAMETERS
 *  void
 * RETURNS
 *  S16 - Current history index
 *****************************************************************************/
static S16 increment(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    ++currHistoryIndex;

    MMI_ASSERT(currHistoryIndex < MAX_HISTORY);

    return currHistoryIndex;
}


/*****************************************************************************
 * FUNCTION
 *  decrement
 * DESCRIPTION
 *  decrement the global currHistoryIndex
 *  
 *  decrement the global currHistoryIndex
 * PARAMETERS
 *  void
 * RETURNS
 *  Returns MMI_HIST_STOP_DELETING if the top screen can't be deleted, MMI_HIST_ALLOW_DELETING otherwise. otherwise.
 *****************************************************************************/
static U8 decrement(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 is_stop_delete = MMI_HIST_ALLOW_DELETING;  /* JL, if want to stop to run next decrement will return true. */
    static U16 cb_history_idx = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* found the callback history screen */
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif /* 0 */ 
    {
        /* is_del_cb_found = SearchDelScrnIDCallbackHandler(historyData[currHistoryIndex].scrnID, &cb_history_idx); */
        if (!bBackHistoryFlag)
        {
            if (SearchDelScrnIDCallbackHandler(historyData[currHistoryIndex].scrnID, &cb_history_idx))
            {
                if (historyCBHandler[cb_history_idx].historydelCBPtr)
                {
                    is_stop_delete = historyCBHandler[cb_history_idx].historydelCBPtr((void*)MMI_HIST_DELETE_SCREEN_TYPE);
                    if (is_stop_delete == MMI_HIST_STOP_DELETING)
                    {
                        return MMI_HIST_STOP_DELETING;
                    }
                    ClearDelScrnIDCallbackHandler(historyCBHandler[cb_history_idx].scrnID, NULL);
                }
            }
        }
    }

    mmi_free_history_buffer(currHistoryIndex);
    memset(&historyData[currHistoryIndex], 0, sizeof(historyNode));

    --currHistoryIndex;
    MMI_ASSERT((currHistoryIndex >= MIN_HISTORY - 1)&&(currHistoryIndex < MAX_HISTORY) );

    return is_stop_delete;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_set_orderly_exit_screen
 * DESCRIPTION
 *  Called by app to tell history that the screen will use the orderly exit 
 *  mechanism, namely calls the active screen's delete callback function and 
 *  exit function at first when goes back to specified screen.   
 * PARAMETERS
 *  void     
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_set_orderly_exit_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {       
        return;
    }
#endif

    PRINT_INFORMATION("[history] void mmi_set_orderly_exit_screen(void)");
    
    mmi_is_orderly_exit_screen = MMI_TRUE;
}


#ifdef OSL_MEMORY_DUMP


/*****************************************************************************
 * FUNCTION
 *  AddHistoryReferenceMemoryRecord
 * DESCRIPTION
 *  adds a history along with memory record
 *  
 *  This is used to add a history
 * PARAMETERS
 *  addHistory      [IN]  Node to be added in history database.      
 *  fileName        [IN]  The file name.       
 *  lineNumber      [IN]  The line number.        
 * RETURNS
 *  void
 *****************************************************************************/
void AddHistoryReferenceMemoryRecord(history *addHistory, char *fileName, int lineNumber)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 length = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        small_history_node = 0;
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    /* 1. Check for OK pressed or BACK pressed */

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_ADD_HISTREFMEMREC_HDLR, (IsBackHistory != MMI_TRUE));

    if (IsBackHistory != MMI_TRUE)
    {

        increment();
        /* 3. Store History to History Data Structure */
        memset(&historyData[currHistoryIndex], 0, sizeof(historyNode));
        historyData[currHistoryIndex].scrnID = addHistory->scrnID;
        historyData[currHistoryIndex].entryFuncPtr = addHistory->entryFuncPtr;
    #ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
        historyData[currHistoryIndex].isSmallScreen = (U16) small_history_node;
    #endif 
        length = mmi_ucs2strlen((PS8) addHistory->inputBuffer);
        MMI_ASSERT(length * ENCODING_LENGTH + ENCODING_LENGTH <= MAX_INPUT_BUFFER);
        if (length)
        {
            historyData[currHistoryIndex].inputBuffer = OslMallocCHK(length * ENCODING_LENGTH + ENCODING_LENGTH, fileName, lineNumber);
            mmi_ucs2cpy((PS8) historyData[currHistoryIndex].inputBuffer, (PS8) addHistory->inputBuffer);
        }
        historyData[currHistoryIndex].guiBuffer = OslMallocCHK(MAX_GUI_BUFFER, fileName, lineNumber);
        memcpy(historyData[currHistoryIndex].guiBuffer, addHistory->guiBuffer, MAX_GUI_BUFFER);
    }
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    small_history_node = 0;
#endif 
    IsBackHistory = MMI_FALSE;
}

#else /* OSL_MEMORY_DUMP */ 


/*****************************************************************************
 * FUNCTION
 *  AddHistoryReference
 * DESCRIPTION
 *  adds a history
 *  
 *  This is used to add a history
 * PARAMETERS
 *  addHistory      [IN]  Node to be added in history database.      
 * RETURNS
 *  void
 *****************************************************************************/
void AddHistoryReference(history *addHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 length = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        small_history_node = 0;
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    /* 1. Check for OK pressed or BACK pressed */

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_ADD_HISTREF_HDLR, (IsBackHistory != MMI_TRUE));

    if (IsBackHistory != MMI_TRUE)
    {

        increment();
        /* 3. Store History to History Data Structure */
        memset(&historyData[currHistoryIndex], 0, sizeof(historyNode));
        historyData[currHistoryIndex].scrnID = addHistory->scrnID;
        historyData[currHistoryIndex].entryFuncPtr = addHistory->entryFuncPtr;
    #ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
        historyData[currHistoryIndex].isSmallScreen = (U16) small_history_node;
    #endif 
        length = mmi_ucs2strlen((PS8) addHistory->inputBuffer);
        MMI_ASSERT(length * ENCODING_LENGTH + ENCODING_LENGTH <= MAX_INPUT_BUFFER);
        if (length)
        {
            historyData[currHistoryIndex].inputBuffer = OslMalloc(length * ENCODING_LENGTH + ENCODING_LENGTH);
            mmi_ucs2cpy((PS8) historyData[currHistoryIndex].inputBuffer, (PS8) addHistory->inputBuffer);
        }
        historyData[currHistoryIndex].guiBuffer = OslMalloc(MAX_GUI_BUFFER);
        memcpy(historyData[currHistoryIndex].guiBuffer, addHistory->guiBuffer, MAX_GUI_BUFFER);
    }
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    small_history_node = 0;
#endif 
    IsBackHistory = MMI_FALSE;
}

#endif /* OSL_MEMORY_DUMP */ 


/*****************************************************************************
 * FUNCTION
 *  AddNHistory_ext
 * DESCRIPTION
 *  adds a history with user specified size
 *  
 *  This is used to add a history where user specifies the size
 * PARAMETERS
 *  addHistory      [IN]  Node to be added in history database.      
 *  size            [IN]  User specifies data size.      
 * RETURNS
 *  void
 *****************************************************************************/
/* MTK Leo add 0511, to reduce stack size */
void AddNHistory_ext(history *addHistory, U16 size)
/* MTK Leo end 0511 */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        small_history_node = 0;
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_ADD_NHIST_HDLR, size, (IsBackHistory != MMI_TRUE));
    /* 1. Check for OK pressed or BACK pressed */

    if (IsBackHistory != MMI_TRUE)
    {

        increment();
        /* 3. Store History to History Data Structure */
        memset(&historyData[currHistoryIndex], 0, sizeof(historyNode));
        historyData[currHistoryIndex].scrnID = addHistory->scrnID;
        historyData[currHistoryIndex].entryFuncPtr = addHistory->entryFuncPtr;

        /* PMT START MAUI_00157013_AND_MAUI_00157021 PATCH */
    #ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
        historyData[currHistoryIndex].isSmallScreen = (U16) small_history_node;
    #endif 

        MMI_ASSERT(size + ENCODING_LENGTH + 2 <= MAX_INPUT_BUFFER);
        historyData[currHistoryIndex].inputBuffer = OslMalloc(size + ENCODING_LENGTH + 2);
        memcpy(historyData[currHistoryIndex].inputBuffer, &size, 2);
        memcpy((PS8) (historyData[currHistoryIndex].inputBuffer + 2), (PS8) addHistory->inputBuffer, (U32) size);

        historyData[currHistoryIndex].guiBuffer = OslMalloc(MAX_GUI_BUFFER);
        memcpy(historyData[currHistoryIndex].guiBuffer, addHistory->guiBuffer, MAX_GUI_BUFFER);
    }
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    small_history_node = 0;
#endif 
    IsBackHistory = MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  AddHistoryEx
 * DESCRIPTION
 *  adds a history with 
 *  
 *  The applications could assign the related function pointer
 *  and let the MMI framework to get history data
 * PARAMETERS
 *  scrnID                  [IN]  the screen id      
 *  entryFuncPtr            [IN]  the screen's entry function
 *  getGuiFuncPtr           [IN]  the function to get GUI data
 *  getInputBufSizeFuncPtr  [IN]  the function to get input buffer size 
 *  getInputBufFuncPtr      [IN]  the function to get input buffer
 *  mallocFuncPtr           [IN]  the function to allocate memory
 *  mfreeFuncPtr            [IN]  the function to free memory
 * RETURNS
 *  Always returns MMI_TRUE.
 *****************************************************************************/
MMI_BOOL AddHistoryEx(
            U16 scrnID,                             /* the screen id */
            FuncPtr entryFuncPtr,                   /* the screen's entry function */
            HistoryGetData getGuiFuncPtr,           /* the function to get GUI data */
            HistoryGetSize getInputBufSizeFuncPtr,  /* the function to get input buffer size */
            HistoryGetData getInputBufFuncPtr,      /* the function to get input buffer */
            MemAlloc mallocFuncPtr,                 /* the function to allocate memory */
            MemFree mfreeFuncPtr)                  /* the function to free memory */
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 inputBuf_size;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        small_history_node = 0;
        return MMI_TRUE;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_ADD_HIST_EX_HDLR, (IsBackHistory != MMI_TRUE));
    /* Check for OK pressed or BACK pressed */
    if (IsBackHistory != MMI_TRUE)
    {
        increment();
        /* Store History to History Data Structure */
        memset(&historyData[currHistoryIndex], 0, sizeof(historyNode));
        historyData[currHistoryIndex].scrnID = scrnID;
        historyData[currHistoryIndex].entryFuncPtr = entryFuncPtr;

    #ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
        historyData[currHistoryIndex].isSmallScreen = (U16) small_history_node;
    #endif
        MMI_ASSERT(getGuiFuncPtr);
        historyData[currHistoryIndex].guiBuffer = OslMalloc(MAX_GUI_BUFFER);
        getGuiFuncPtr(historyData[currHistoryIndex].guiBuffer);

        historyData[currHistoryIndex].mallcFuncPtr = mallocFuncPtr;
        historyData[currHistoryIndex].mfreeFuncPtr = mfreeFuncPtr;
        if (getInputBufSizeFuncPtr)
        {
            MMI_ASSERT(getInputBufFuncPtr);
            inputBuf_size = (S16)getInputBufSizeFuncPtr();
            if(mallocFuncPtr)
            {
                /* Check memory free function pointer is valid */
                MMI_ASSERT(mfreeFuncPtr);
                historyData[currHistoryIndex].inputBuffer = (U8*)mallocFuncPtr(inputBuf_size + ENCODING_LENGTH + 2);
            }
            else
            {
                historyData[currHistoryIndex].inputBuffer = OslMalloc(inputBuf_size + ENCODING_LENGTH + 2);
            }
            memcpy(historyData[currHistoryIndex].inputBuffer, &inputBuf_size, 2);
            getInputBufFuncPtr(historyData[currHistoryIndex].inputBuffer + 2);
        }
    }
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    small_history_node = 0;
#endif 
    IsBackHistory = MMI_FALSE;

    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  GetHistory
 * DESCRIPTION
 *  Used to get the history buffer for a screen id
 * PARAMETERS
 *  scrnID          [IN]  The screen ID of the history node.      
 *  ptrHistory      [OUT] The history buffer of the specified screen ID.       
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 GetHistory(U16 scrnID, history *ptrHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    U16 nSize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_GET_HIST_HDLR, scrnID, currHistoryIndex);

    count = searched_history_node(currHistoryIndex, scrnID);
    if (count < 0 )
    {
        return ST_FAILURE;
    }
    ptrHistory->entryFuncPtr = historyData[count].entryFuncPtr;
    ptrHistory->scrnID = historyData[count].scrnID;
    if (historyData[count].guiBuffer)
    {
        memcpy(ptrHistory->guiBuffer, historyData[count].guiBuffer, MAX_GUI_BUFFER);
    }
    else
    {
        memset(ptrHistory->guiBuffer, 0, MAX_GUI_BUFFER);
    }
    if (historyData[count].inputBuffer)
    /* 2 Bytes Are Added By UI To Keep Size Of InputBuffer Internally In AddNHistory */
    {
        memcpy(&nSize, historyData[count].inputBuffer, 2);
        memcpy(
               ptrHistory->inputBuffer,
               historyData[count].inputBuffer + 2,
               (nSize > MAX_INPUT_BUFFER) ? MAX_INPUT_BUFFER : nSize);
    }
    else
    {
        memset(ptrHistory->inputBuffer, 0, MAX_INPUT_BUFFER);
    }
    return ST_SUCCESS;

}


/*****************************************************************************
 * FUNCTION
 *  GetHistoryPointer
 * DESCRIPTION
 *  Used to get the reference of the history buffer for a screen id
 * PARAMETERS
 *  scrnID       [IN]   The screen ID of the history node.     
 *  ptrHistory   [OUT]  The pointer to the history buffer of the specified screen ID.      
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 GetHistoryPointer(U16 scrnID, historyNode **ptrHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_GET_HIST_SCRID_HDLR, scrnID, currHistoryIndex);

    count = searched_history_node(currHistoryIndex, scrnID);
    if (count < 0 )
        {
        return ST_FAILURE;
        }
    *ptrHistory = &historyData[count];

    return ST_SUCCESS;

}


/*****************************************************************************
 * FUNCTION
 *  GetHistoryScrID
 * DESCRIPTION
 *  Used to get the reference of the history buffer for a screen id
 *  
 *  Please change to use GetHistoryPointer,
 *  rather than GetHistoryScrID
 * PARAMETERS
 *  scrnID          [IN]   The screen ID of the history node.     
 *  ptrHistory      [OUT]  The history buffer of the specified screen ID.      
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 GetHistoryScrID(U16 scrnID, historyNode **ptrHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return GetHistoryPointer(scrnID, ptrHistory);
}


/*****************************************************************************
 * FUNCTION
 *  GetNHistory
 * DESCRIPTION
 *  Used to get the history for a screen id, and also the history buffer size
 * PARAMETERS
 *  scrnID          [IN]   The screen ID of the history node.     
 *  ptrHistory      [OUT]  The history buffer of the specified screen ID.         
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 GetNHistory(U16 scrnID, history *ptrHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    U8 Status = ST_FAILURE;
    U16 size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_GET_NHIST_HDLR, scrnID, currHistoryIndex);

    count = currHistoryIndex;
    do
    {
        if (scrnID == historyData[count].scrnID)
        {
            ptrHistory->entryFuncPtr = historyData[count].entryFuncPtr;
            ptrHistory->scrnID = historyData[count].scrnID;
            if (historyData[count].guiBuffer)
            {
                memcpy(ptrHistory->guiBuffer, historyData[count].guiBuffer, MAX_GUI_BUFFER);
            }
            else
            {
                memset(ptrHistory->guiBuffer, 0, MAX_GUI_BUFFER);
            }
            if (historyData[count].inputBuffer)
            {
                memcpy((PS8) & size, historyData[count].inputBuffer, 2);
                memcpy(ptrHistory->inputBuffer, (PS8) (historyData[count].inputBuffer + 2), size);
            }
            else
            {
                memset(ptrHistory->inputBuffer, 0, MAX_INPUT_BUFFER);
            }
            Status = ST_SUCCESS;
            break;
        }

        if (count > MIN_HISTORY + 1 && count < MAX_HISTORY)
        {
            --count;
        }
        else
        {
                break;  /* Status is by default FAILURE so no need to set again */
        }

    } while ((count != currHistoryIndex) && (historyData[count].entryFuncPtr != NULL));

    return Status;

}


/*****************************************************************************
 * FUNCTION
 *  CheckIsBackHistory
 * DESCRIPTION
 *  Is in GoBackHistory
 *  
 *  This is typically used by entry function
 * PARAMETERS
 *  void
 * RETURNS
 *  Returns MMI_TRUE if in GoBackHistory; MMI_FALSE otherwise.
 *****************************************************************************/
pBOOL CheckIsBackHistory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return bBackHistoryFlag;
}


/*****************************************************************************
 * FUNCTION
 *  GoBackHistory
 * DESCRIPTION
 *  deletes previous screen history
 *  
 *  This is used to delete previous screen history
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
#if defined(__DIRECT_ENTRY_FACTORY_MODE_ON_BOOTUP__)
extern BOOL DirectMode;
extern void CallBackPowerOnAnimationCompleteWrapper(void);
#endif /* defined(__DIRECT_ENTRY_FACTORY_MODE_ON_BOOTUP__) */ 

void GoBackHistory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#if defined(__DIRECT_ENTRY_FACTORY_MODE_ON_BOOTUP__)
    BOOL Exit_From_FM = (DirectMode && currHistoryIndex == -1);
#endif 

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_GO_BACK_HIST_HDLR);
    
    mmi_is_orderly_exit_screen = MMI_FALSE;

    ExecutePopHistory();

#if defined(__DIRECT_ENTRY_FACTORY_MODE_ON_BOOTUP__)
    if (Exit_From_FM)
    {
        CallBackPowerOnAnimationCompleteWrapper();
    }
#endif /* defined(__DIRECT_ENTRY_FACTORY_MODE_ON_BOOTUP__) */ 

}


/*****************************************************************************
 * FUNCTION
 *  GoBackToHistory
 * DESCRIPTION
 *  Goes back to specified screen
 * PARAMETERS
 *  scrnid      [IN]  Screen ID of screen which needs to be displayed.        
 * RETURNS
 *  void
 *****************************************************************************/
U8 GoBackToHistory(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    U8 Status = ST_FAILURE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ST_SUCCESS;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_GO_BACK_TO_HIST_HDLR, scrnid);

    /* To make sure the callback will run at topist screen, and callback for APP */
    ExecTopScrnCallbackHandler();

    if (mmi_is_orderly_exit_screen)
    {        
        IsBackHistory = MMI_TRUE;
        CheckMainLCDHistoryBack = MMI_TRUE;
        bBackHistoryFlag = MMI_TRUE;

        ExecuteCurrExitHandler();
        
        IsBackHistory = MMI_FALSE;
        CheckMainLCDHistoryBack = MMI_FALSE;
        bBackHistoryFlag = MMI_FALSE;        
    }

    count = currHistoryIndex;

    do
    {
        if (historyData[currHistoryIndex].scrnID == scrnid)
        {
            Status = ST_SUCCESS;
            break;
        }

        /* Chack added when amit is doing testing on h/w for call management */
        if (currHistoryIndex > 0)
        {
            if (decrement() == MMI_HIST_STOP_DELETING)
            {
                /* We abort the process here and don't handle original requirement */
                Status = ST_SUCCESS;
                break;
            }
        }
    } while ((count != currHistoryIndex) && (historyData[currHistoryIndex].entryFuncPtr != NULL)
             && (currHistoryIndex > 0));

    if (Status)
    {
        ExecutePopHistory();
    }
    else if (currHistoryIndex > -1)
    {
        /* To make sure the callback will run at topist screen */
        ExecTopScrnCallbackHandler();
        (*(historyData[0].entryFuncPtr)) ();
        currHistoryIndex = -1;
    }

    return Status;
}


/*****************************************************************************
 * FUNCTION
 *  GoBacknHistory
 * DESCRIPTION
 *  Goes 'n' screens back
 * PARAMETERS
 *  nHistory        [IN] Number of screens one want to go back.       
 * RETURNS
 *  void
 *****************************************************************************/
void GoBacknHistory(U16 nHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 Index = 0;
    S16 Count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_GO_BACK_NHIST_HDLR, nHistory);

    /* To make sure the callback will run at topist screen, and callback for APP */
    ExecTopScrnCallbackHandler();

    if (mmi_is_orderly_exit_screen)
    {        
        IsBackHistory = MMI_TRUE;
        CheckMainLCDHistoryBack = MMI_TRUE;
        bBackHistoryFlag = MMI_TRUE;
        
        ExecuteCurrExitHandler();

        IsBackHistory = MMI_FALSE;
        CheckMainLCDHistoryBack = MMI_FALSE;
        bBackHistoryFlag = MMI_FALSE; 
    }

    Index = currHistoryIndex;
    
    if (Index >= nHistory)
    {
        for (Count = nHistory; Count >= 1; --Count)
        {
            /* JL, if want to stop to run next decrement will return true. */
            if (decrement() == MMI_HIST_STOP_DELETING)
            {
                /* We abort the process here and don't handle original requirement */
                break;
            }
        }
        ExecutePopHistory();
    }
}


/*****************************************************************************
 * FUNCTION
 *  ExecutePopHistory
 * DESCRIPTION
 *  executes current scrn & then deletes from history
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void ExecutePopHistory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_EXE_POP_HIST_HDLR, GetActiveScreenId(), GetExitScrnID(), IsBackHistory, CheckMainLCDHistoryBack);

    IsBackHistory = MMI_TRUE;
    CheckMainLCDHistoryBack = MMI_TRUE;
    bBackHistoryFlag = MMI_TRUE;

    if (historyData[currHistoryIndex].entryFuncPtr && currHistoryIndex > 0)
    {
        U16 id;

        /* To make sure the callback will run at topist screen */
        ExecTopScrnCallbackHandler();

        //entryFuncPtr = (*(historyData[currHistoryIndex].entryFuncPtr));
        //decrement(MMI_TRUE);
        //entryFuncPtr();

        id = historyData[currHistoryIndex].scrnID;
    #ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
        if (historyData[currHistoryIndex].isSmallScreen)
        {
            S32 i;
            S32 tmp = currHistoryIndex;

            i = currHistoryIndex - 1;
            while (historyData[i].isSmallScreen && i > 0)
            {
                i--;
            }
            if ((currHistoryIndex == 0) || (i == 0 && historyData[i].isSmallScreen))
            {
                clear_screen();
            }

            redrawing_old_screens = MMI_HIST_SMALLSCREEN_ACTIVE;
            MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_EXE_SMALL_SCREEN_BEGIN, currHistoryIndex, i);
            gdi_lcd_freeze(TRUE);
            
            /* force small screen flatten always on */
            dm_force_small_screen_flatten();
                        
        #ifdef __MMI_INTERACTIVE_PROFILNG__
            mmi_frm_profiling_interactive_start();
        #endif 
            while ((i < currHistoryIndex) && (i >= 0))
            {
                currHistoryIndex = i;
                IsBackHistory = MMI_TRUE;
                CheckMainLCDHistoryBack = MMI_TRUE;
                if (historyData[i].entryFuncPtr)
                {
                    (*(historyData[i].entryFuncPtr)) ();
                }
                i++;
            }
            
            /* unforce small screen flatten always on */
            dm_unforce_small_screen_flatten();            
            
            gdi_lcd_freeze(FALSE);
            IsBackHistory = MMI_TRUE;
            CheckMainLCDHistoryBack = MMI_TRUE;
            redrawing_old_screens = MMI_HIST_SMALLSCREEN_ACTIVE_IN_EXIT_FUNC;
            currHistoryIndex = tmp;
            MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_EXE_SMALL_SCREEN_END, historyData[currHistoryIndex].scrnID, historyData[currHistoryIndex].entryFuncPtr);
            if (historyData[currHistoryIndex].entryFuncPtr)
            {
                (*(historyData[currHistoryIndex].entryFuncPtr)) ();
            }
        #ifdef __MMI_INTERACTIVE_PROFILNG__
            mmi_frm_profiling_interactive_end();
            mmi_frm_profiling_interactive_show((U8*) L"S", MMI_FRM_PROFILING_MASK_1);
        #endif /* __MMI_INTERACTIVE_PROFILNG__ */ 

            if (id == historyData[currHistoryIndex].scrnID)
            {
                decrement();
            }
            /*
             * We changet the small screen procedure state here.
             * When we execute the last entry function, 
             * it also executed the previous exit function.
             * We still don't want to add the history in that case.
             */
             redrawing_old_screens = MMI_HIST_SMALLSCREEN_NONE;
        }
        else
    #endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
        {
        #ifdef __MMI_INTERACTIVE_PROFILNG__
            mmi_frm_profiling_interactive_start();
            if (historyData[currHistoryIndex].entryFuncPtr)
            {
                (*(historyData[currHistoryIndex].entryFuncPtr)) ();
            }
            mmi_frm_profiling_interactive_end();
            mmi_frm_profiling_interactive_show((U8*) L"S", MMI_FRM_PROFILING_MASK_1);
        #else /* __MMI_INTERACTIVE_PROFILNG__ */ 
            if (historyData[currHistoryIndex].entryFuncPtr)
            {
                (*(historyData[currHistoryIndex].entryFuncPtr)) ();
            }
        #endif /* __MMI_INTERACTIVE_PROFILNG__ */ 
            if (id == historyData[currHistoryIndex].scrnID)
            {
                decrement();
            }
        }
    }
    else
    {
        
        /* To make sure the callback will run at topist screen */
        ExecTopScrnCallbackHandler();
        /* Go to idle screen */
        currHistoryIndex = -1;
        if ((historyData[0].entryFuncPtr))
        {
        #ifdef __MMI_INTERACTIVE_PROFILNG__
            mmi_frm_profiling_interactive_start();
            (*(historyData[0].entryFuncPtr)) ();
            mmi_frm_profiling_interactive_end();
            mmi_frm_profiling_interactive_show((U8*) L"S", MMI_FRM_PROFILING_MASK_1);
        #else /* __MMI_INTERACTIVE_PROFILNG__ */ 
            (*(historyData[0].entryFuncPtr)) ();
        #endif /* __MMI_INTERACTIVE_PROFILNG__ */ 
        }

        /*
         * Some index[0] screen will execute DinitHistory() to free historyData[0] data,
         * and add its screen info. into history[0].
         * ex. EntryIdleScreen, EntryScrnSimErrorScreen, EntryScrnSimBlockRsp, ...
         * We don't need to free history node here again.
         */
        if (bDinitHistoryFlag)
        {
            bDinitHistoryFlag = MMI_FALSE;
        }
        else
        {
            mmi_free_history_buffer(0);
            memset(&historyData[0], 0, sizeof(historyNode));
        }

        IsBackHistory = MMI_FALSE;

    }

    CheckMainLCDHistoryBack = MMI_FALSE;
    bBackHistoryFlag = MMI_FALSE;
    // reset delete CB flag, while go back screen.
    //is_del_cb_found = MMI_FALSE; // gilbert --- for modifying decrement()

}


/*****************************************************************************
 * FUNCTION
 *  GetCurrScrnId
 * DESCRIPTION
 *  Gets the id of the screen on the top of history stack.
 *  
 *  This is used to get current screen input buffer
 * PARAMETERS
 *  void
 * RETURNS
 *  U16 - Current Screen Id
 *****************************************************************************/
U16 GetCurrScrnId(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (historyData[currHistoryIndex].scrnID);
}


/*****************************************************************************
 * FUNCTION
 *  DeleteScreens
 * DESCRIPTION
 *  Deletes the screen IDs in the history
 *  The start screen ID and end screen ID will be deleted.
 *  If all screen IDs in the history are deleted
 *  successfully, the function returns ST_SUCCESS.
 *  If the parameters are error or someone screen
 *  ID can't be deleted successfully, the function
 *  returns ST_FAILURE.
 * PARAMETERS
 *  start_scrnid        [IN]        IN  the start screen ID (small number)
 *  end_scrnid          [IN]        IN  the end screen ID (big number)
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 DeleteScreens(U16 start_scrnid, U16 end_scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0, del_cnt = 0, i = 0;
    U8 Status = ST_SUCCESS;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ST_SUCCESS;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_DEL_SCRS_HDLR, start_scrnid, end_scrnid);

    count = currHistoryIndex;

    if (start_scrnid > end_scrnid)
    {
        return ST_FAILURE;
    }

    while (count)
    {
        if ((start_scrnid <= historyData[count].scrnID) && (historyData[count].scrnID <= end_scrnid))
        {
            if (ExecHistoryScrnCallBackHandle(count) == MMI_HIST_STOP_DELETING)
            {
                /*
                 * The screen won't want to delete. 
                 * We stop continue to delete the screens.
                 */
                Status = ST_FAILURE;
                break;
            }
            del_cnt++;
            /* Deleting the node */
            mmi_free_history_buffer(count);
            /* Shifting All the nodes by one notch */
            for (i = 0; i <= (currHistoryIndex - count); i++)
            {
                memcpy(&historyData[count + i], &historyData[count + i + 1], sizeof(historyNode));
            }
        }
        count--;
    }

    currHistoryIndex -= del_cnt;
    MMI_ASSERT(currHistoryIndex>=0);
    memset(&historyData[currHistoryIndex + 1], 0, sizeof(historyNode));

    return Status;
}


/*****************************************************************************
 * FUNCTION
 *  DeleteBeyondScrTillScr
 * DESCRIPTION
 *  To delete screens beyond screen ID - beyondScrnID till screen ID - tillScrnID. 
 *  Both beyondScrnID and tillScrnID have to be in history database, or the 
 *  function will return fail. And within the History stack the beyondScrnid position 
 *  is reachable from the tillScrnid by decrementation. Otherwise an assert failure 
 *  occurs.
 * PARAMETERS
 *  beyondScrnid        [IN]   Specify the beyond Screen ID wants to delete the nodes.[Exclusive]      
 *  tillScrnid          [IN]   Specify the till Screen ID wants to delete the nodes.  [Inclusive]  
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 DeleteBeyondScrTillScr(U16 beyondScrnid, U16 tillScrnid)
{
#ifdef NEW_DEL_API
    return DeleteHistory(beyondScrnid, 0, 0, tillScrnid, 1);
#else
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 Status = ST_SUCCESS;
    U16 count = 0, count1 = 0;
    S16 endScreenPresent = -1, startScreenPresent = -1;
    U16 screensDeleted = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ST_SUCCESS;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_DEL_BEYOND_SCR_TILL_SCR_HDLR, beyondScrnid, tillScrnid);

    if (currHistoryIndex > 0)
    {
        count = currHistoryIndex;
        count1 = currHistoryIndex;
    }

    startScreenPresent = searched_history_node(currHistoryIndex, beyondScrnid);

    if (startScreenPresent > 0)
    {
        endScreenPresent = searched_history_node(startScreenPresent, tillScrnid);        
    }
    else
    {
        return ST_FAILURE;
    }
    MMI_ASSERT((startScreenPresent != -1) && (endScreenPresent != -1));

    for (count = startScreenPresent - 1; count >= endScreenPresent; count--)
    {
        if (ExecHistoryScrnCallBackHandle(count) == MMI_HIST_STOP_DELETING)
        {
            /*
             * The screen won't want to delete. 
             * We stop continue to delete the screens.
             */
            endScreenPresent = count + 1;
            Status = ST_FAILURE;
            break;
        }
        mmi_free_history_buffer(count);
        memset(&historyData[count], 0, sizeof(historyNode));
        currHistoryIndex--;
        screensDeleted++;
        if (count == 0)
        {
            /* count is U16 not S16 */
            break;
        }
    }

    memcpy(
        historyData + endScreenPresent,
        historyData + startScreenPresent,
        sizeof(historyNode) * (count1 - startScreenPresent + 1));
    memset(historyData + (currHistoryIndex + 1), 0, (sizeof(historyNode) * screensDeleted));

    return Status;
#endif /* NEW_DEL_API */
}


/*****************************************************************************
 * FUNCTION
 *  DeleteBetweenScreen
 * DESCRIPTION
 *  Deletes Between two Screens including the boundaries
 *  To delete screens between screen ID - StartScrnID till screen ID EndScrnID. 
 *  Both StartScrID and EndScrnID have to be in history database, or the function
 *  will return fail. And within the History stack the StartScrId position is reachable 
 *  from the EndScrId by decrementation. Otherwise an assert failure occurs.
 * PARAMETERS
 *  StartScrId      [IN]  Specify the beginning Screen ID wants to delete the nodes. [Inclusive].      
 *  EndScrId        [IN]  Specify the endding Screen ID wants to delete the nodes.   [Inclusive].      
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U16 DeleteBetweenScreen(U16 StartScrId, U16 EndScrId)
{
#ifdef NEW_DEL_API
    return DeleteHistory(EndScrId, 1, 0, StartScrId, 1);
#else
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 Status = ST_SUCCESS;
    U16 count = 0, count1 = 0;
    S16 endScreenPresent = -1, startScreenPresent = -1;
    U16 screensDeleted = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ST_SUCCESS;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_DEL_BETWEEN_SCR_HDLR, StartScrId, EndScrId);

    if (currHistoryIndex > 0)
    {
        count = currHistoryIndex;
        count1 = currHistoryIndex;
    }

    startScreenPresent = searched_history_node(currHistoryIndex, EndScrId);

    if (startScreenPresent >= 0)
    {
        endScreenPresent = searched_history_node(startScreenPresent, StartScrId);        
    }
    else
    {
        return ST_FAILURE;
    }

    MMI_ASSERT((startScreenPresent != -1) && (endScreenPresent != -1));
    for (count = startScreenPresent; count >= endScreenPresent; count--)
    {
        if (ExecHistoryScrnCallBackHandle(count) == MMI_HIST_STOP_DELETING)
        {
            /*
             * The screen won't want to delete. 
             * We stop continue to delete the screens.
             */
            endScreenPresent = count + 1;
            Status = ST_FAILURE;
            break;
        }

        mmi_free_history_buffer(count);
        currHistoryIndex--;
        screensDeleted++;
        if (count == 0)
        {
            /* count is U16 not S16 */
            break;
        }
    }
    memcpy(
        historyData + endScreenPresent,
        historyData + startScreenPresent + 1,
        sizeof(historyNode) * (count1 - startScreenPresent + 1));
    memset(historyData + (currHistoryIndex + 1), 0, (sizeof(historyNode) * screensDeleted));

    return ST_SUCCESS;
#endif /* NEW_DEL_API */
}


/*****************************************************************************
 * FUNCTION
 *  DeleteScreenIfPresent
 * DESCRIPTION
 *  This function Deletes specified screen ID history nodes from the history 
 *  database. The screen ID should be in the history database, or the function 
 *  will return fail.
 * PARAMETERS
 *  ScrId       [IN] Specify the Screen ID wants to delete the nodes.       
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U16 DeleteScreenIfPresent(U16 ScrId)
{
    /*
     * return DeleteHistory(ScrId, 1, 1, 0, 0);
     * This function can't use the new del API. If it uses the new API, the  
     * original API's behavior will be changed. The original behavior is that
     * immediately delete the screen, doesn't consider whether the screen 
     * allow to delete or not.       
     */ 
        
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;
    U16 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ST_SUCCESS;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_DEL_SCR_IF_PRESENT_HDLR, ScrId);
    

    count = searched_history_node(currHistoryIndex, ScrId);
    if (count < 0)
    {
        return ST_FAILURE;
    }

    /*
     * Not support for stop callback at this funciton 
     * Because the application want to delete the special screen in the history,
     * we don't need to check the return value of the delete callback function.
     */
    ExecHistoryScrnCallBackHandle(count);

    /* Deleting the node */
    mmi_free_history_buffer(count);

    /* Shifting All the nodes by one notch */
    for (i = count + 1; i <= currHistoryIndex; i++, count++)
    {
        memcpy(&historyData[count], &historyData[i], sizeof(historyNode));
    }

    --currHistoryIndex;
    memset(&historyData[currHistoryIndex + 1], 0, sizeof(historyNode));
    return ST_SUCCESS;

}


/*****************************************************************************
 * FUNCTION
 *  DeleteScreenFromToNnodes
 * DESCRIPTION
 *  Deletes N nodes from  History starting from a particular screen
 * PARAMETERS
 *  ScrId           [IN]  Specify the Screen ID wants to delete the nodes.      
 *  num_nodes       [IN]  The number of the history node to delete.      
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U16 DeleteScreenFromToNnodes(U16 ScrId, U16 num_nodes)
{
#ifdef NEW_DEL_API
    return DeleteHistory(ScrId, 1, num_nodes, 0, 0);
#else
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;
    U16 i;
    U16 temp = 0;
    U16 k = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ST_SUCCESS;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_DEL_SCR_FROM_TO_N_NODE_HDLR, ScrId, num_nodes);

    count = searched_history_node(currHistoryIndex, ScrId);
    if (count < 0)
    {
        return ST_FAILURE;
    }

    for (temp = 0; temp < num_nodes; temp++)
    {
        /* Not support for stop callback at this funciton */
        if (ExecHistoryScrnCallBackHandle(count) == MMI_HIST_STOP_DELETING)
        {
            /*
             * The screen won't want to delete. 
             * We stop continue to delete the screens.
             */
            return ST_FAILURE;
        }

        /* Deleting the node */
        mmi_free_history_buffer(count);

        /* Shifting All the nodes by one notch */
        k = count;
        for (i = k + 1; i <= currHistoryIndex; i++, k++)
        {
            memcpy(&historyData[k], &historyData[i], sizeof(historyNode));
        }

        currHistoryIndex--;
        memset(&historyData[currHistoryIndex + 1], 0, sizeof(historyNode));

        count--;
        if ((count == 0) && ((temp + 1) < num_nodes))
        {
            return ST_FAILURE;
        }
    }

    return ST_SUCCESS;
#endif /* NEW_DEL_API */
}


/*****************************************************************************
 * FUNCTION
 *  DeleteFromScrUptoScr
 * DESCRIPTION
 *  Deletes screen from start scrnid to before end scrnid
 *  (include start scrnid but not include end scrnid)
 *  And within the History stack the upto_scrnid position is reachable from the 
 *  start_scrnid by decrementation. Otherwise an assert failure 
 *  occurs.
 * PARAMETERS
 *  start_scrnid        [IN] Specify the beginning Screen ID wants to delete the nodes. [Inclusive]    
 *  upto_scrnid         [IN] Specify the endding Screen ID wants to delete the nodes.   [Exclusive]    
 * RETURNS
 *  Returns ST_SUCCESS if success; ST_FAILURE otherwise.
 *****************************************************************************/
U8 DeleteFromScrUptoScr(U16 start_scrnid, U16 upto_scrnid)
{
#ifdef NEW_DEL_API
    return DeleteHistory(start_scrnid, 1, 0, upto_scrnid, 0);
#else
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 Status = ST_SUCCESS;
    S16 count = 0, count1 = 0;
    S16 endScreenPresent = -1, startScreenPresent = -1;
    U16 screensDeleted = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ST_SUCCESS;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_DEL_FROM_SCR_UPTO_SCR_HDLR, start_scrnid, upto_scrnid);

    if (currHistoryIndex > 0)
    {
        count = currHistoryIndex;
        count1 = currHistoryIndex;
    }

    startScreenPresent = searched_history_node(currHistoryIndex, start_scrnid);

    if (startScreenPresent > 0)
    {
        endScreenPresent = searched_history_node(startScreenPresent, upto_scrnid);        
    }
    else
    {
        return ST_FAILURE;
    }

    MMI_ASSERT((startScreenPresent != -1) && (endScreenPresent != -1));
    for (count = startScreenPresent; count > endScreenPresent; count--)
    {
        if (ExecHistoryScrnCallBackHandle(count) == MMI_HIST_STOP_DELETING)
        {
            /*
             * The screen won't want to delete. 
             * We stop continue to delete the screens.
             */
            endScreenPresent = count + 1;
            Status = ST_FAILURE;
            break;
        }
        mmi_free_history_buffer(count);
        memset(&historyData[count], 0, sizeof(historyNode));
        currHistoryIndex--;
        screensDeleted++;
    }

    memcpy(
        historyData + endScreenPresent + 1,
        historyData + startScreenPresent + 1,
        sizeof(historyNode) * (count1 - startScreenPresent));
    memset(historyData + (currHistoryIndex + 1), 0, (sizeof(historyNode) * screensDeleted));

    return Status;
#endif /* NEW_DEL_API */
}


/*****************************************************************************
 * FUNCTION
 *  InsertHistoryBeforeThisScrnReference
 * DESCRIPTION
 *  Insert new screen into history before this screen
 * PARAMETERS
 *  scrnId          [IN] The specified screen ID.       
 *  addHistory      [IN] The node to be added to  history database.       
 * RETURNS
 *  void
 *****************************************************************************/
void InsertHistoryBeforeThisScrnReference(U16 scrnId, history *addHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    U16 i = 0;
    S32 len = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_INSERT_HIST_BEFORE_SCREEN_HDLR, scrnId);
    
    /* find this screen in history */
    count = searched_history_node(currHistoryIndex, scrnId);
    if (count < 0)
    {
        return;
    }
    
    increment();
    /* Shifting All the nodes by one notch */
    for (i = currHistoryIndex; i != count; i--)
    {
        memcpy(&historyData[i], &historyData[i - 1], sizeof(historyNode));
    }
    /* insert new screen in hostory   */
    memset(&historyData[count], 0, sizeof(historyNode));
    historyData[count].scrnID = addHistory->scrnID;
    historyData[count].entryFuncPtr = addHistory->entryFuncPtr;
    len = mmi_ucs2strlen((PS8) addHistory->inputBuffer);
    if (len)
    {
        historyData[count].inputBuffer = OslMalloc(len * ENCODING_LENGTH + ENCODING_LENGTH);
        mmi_ucs2cpy((PS8) historyData[count].inputBuffer, (PS8) addHistory->inputBuffer);
    }
    historyData[count].guiBuffer = OslMalloc(MAX_GUI_BUFFER);
    memcpy(historyData[count].guiBuffer, addHistory->guiBuffer, MAX_GUI_BUFFER);
    /* return success */
    return;
}


/*****************************************************************************
 * FUNCTION
 *  InsertHistoryAfterThisScrnReference
 * DESCRIPTION
 *  Insert new screen into history after this screen
 * PARAMETERS
 *  scrnId          [IN] The specified screen ID.       
 *  addHistory      [IN] The node to be added to  history database.       
 * RETURNS
 *  If the screen doesn't exist in history will return MMI_FALSE, otherwise 
 *  return MMI_TRUE.
 *****************************************************************************/
MMI_BOOL InsertHistoryAfterThisScrnReference(U16 scrnId, history *addHistory)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    U16 i = 0;
    S32 len = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
       
    /* find this screen in history */
    count = searched_history_node(currHistoryIndex, scrnId);
    if (count < 0)
    {
        return MMI_FALSE;
    }

    count++;    
    increment();
    
    /* Shifting All the nodes by one notch */
    i = currHistoryIndex;    
    while(i > count)
    {
        memcpy(&historyData[i], &historyData[i - 1], sizeof(historyNode));
        i--;
    }
    
    /* insert new screen in hostory   */
    memset(&historyData[count], 0, sizeof(historyNode));
    historyData[count].scrnID = addHistory->scrnID;
    historyData[count].entryFuncPtr = addHistory->entryFuncPtr;
    len = mmi_ucs2strlen((PS8) addHistory->inputBuffer);
    if (len)
    {
        historyData[count].inputBuffer = OslMalloc(len * ENCODING_LENGTH + ENCODING_LENGTH);
        mmi_ucs2cpy((PS8) historyData[count].inputBuffer, (PS8) addHistory->inputBuffer);
    }
    historyData[count].guiBuffer = OslMalloc(MAX_GUI_BUFFER);
    memcpy(historyData[count].guiBuffer, addHistory->guiBuffer, MAX_GUI_BUFFER);
    /* return success */
    return MMI_TRUE;
}



/*****************************************************************************
 * FUNCTION
 *  searched_history_node
 * DESCRIPTION
 *  The function is used for look up the history index mapped to a given screen id. 
 * PARAMETERS
 *  first_index     [IN] The index of the first history node to be searched.        
 *  scrn_id         [IN] Specifies the screen ID to be searched.       
 * RETURNS
 *  returns the index of the screen in history. If no such screen exists, 
 *  the function returns a negative.
 *****************************************************************************/ 
static S16 searched_history_node(S16 first_index, U16 scrn_id)
{    
    while (first_index >= 0)
    {
        if (historyData[first_index].scrnID == scrn_id)
        {
            break;
        }
        --first_index;
    }
    return first_index;    
}


/*****************************************************************************
 * FUNCTION
 *  GetScreenCountInHistory
 * DESCRIPTION
 *  Get the screen numbers in the history
 * PARAMETERS
 *  void
 * RETURNS
 *  S16 - screen count
 *****************************************************************************/
S16 GetScreenCountInHistory(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (currHistoryIndex + 1);
}


/*****************************************************************************
 * FUNCTION
 *  GetCurrInputBuffer
 * DESCRIPTION
 *  This is used to get current screen input buffer.
 *  This function is used to retrieve current Input buffer. In Input buffer all 
 *  running text related information is stored by framework whenever this screen
 *  is overwritten. The application use this function to get Input buffer pointer
 *  of MMI history database directly, its size is not exceed MAX_INPUT_BUFFER and
 *  its life cycle in during this screen is active. If the current screen ID 
 *  isn't the same with the input parameter, the function will return NULL input
 *  buffer pointer.
 * PARAMETERS
 *  scrnid      [IN]  Screen ID of screen whose corresponding Input buffer is to be retrieved.       
 * RETURNS
 *  Pointer to unsigned char pointing to the Input buffer returned.
 *****************************************************************************/
U8 *GetCurrInputBuffer(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_GET_CUR_INPUT_BUF_HDLR, scrnid);

    count = currHistoryIndex;

    if (historyData[currHistoryIndex].scrnID == scrnid)
    {
        return (historyData[count].inputBuffer);
    }
    else
    {
        return NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetCurrNInputBuffer
 * DESCRIPTION
 *  This function is used to retrieve current Input buffer with the Inptut buffer
 *  size. In Input buffer all running text related information is stored by 
 *  framework whenever this screen is overwritten. The application use this 
 *  function to get Input buffer pointer of MMI history database directly, its 
 *  size could be larger than MAX_INPUT_BUFFER and its life cycle in during this
 *  screen is active. If the current screen ID isn't the same with the input 
 *  parameter, the function will return NULL Input buffer pointer.
 * PARAMETERS
 *  scrnid      [IN] Screen ID of screen whose corresponding Input buffer is to be retrieved.       
 *  size        [IN] The Input buffer size.       
 * RETURNS
 *  Pointer to unsigned char pointing to the Input buffer returned.
 *****************************************************************************/
U8 *GetCurrNInputBuffer(U16 scrnid, U16 *size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_GET_CUR_NINPUT_BUF_HDLR, scrnid);

    if (historyData[currHistoryIndex].scrnID == scrnid)
    {
        if (NULL == historyData[currHistoryIndex].inputBuffer)
        {
            *size = 0;
            return NULL;
        }
        else
        {
        memcpy(size, historyData[currHistoryIndex].inputBuffer, 2);
        return ((historyData[currHistoryIndex].inputBuffer) + 2);
        }
    }
    else
    {
        *size = 0;
        return NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  GetCurrGuiBuffer
 * DESCRIPTION
 *  This function is used to retrieve current GUI buffer. In GUI buffer all GUI 
 *  related information is stored by framework whenever this screen is overwritten.
 *  The application use this function to get GUI buffer pointer of MMI history 
 *  database directly and its life cycle in during this screen is active. If the
 *current screen ID isn't the same with the input parameter, the function will
 *  return NULL GUI buffer pointer.
 * PARAMETERS
 *  scrnid      [IN] Screen ID of screen whose corresponding GUI buffer is to be retrieved.       
 * RETURNS
 *  Pointer to unsigned char pointing to the GUI buffer returned. 
 *****************************************************************************/
U8 *GetCurrGuiBuffer(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_GET_CUR_GUI_BUF_HDLR, scrnid, currHistoryIndex);
    
    if (-1 == currHistoryIndex)
    {
    	if (historyData[0].scrnID == scrnid)
    	{
            return (historyData[0].guiBuffer);
    	}    		
    } 
    else if (historyData[currHistoryIndex].scrnID == scrnid)
    {
        return (historyData[currHistoryIndex].guiBuffer);
    }
       
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  GetCurrGuiBuffer_Ex
 * DESCRIPTION
 *  This function is used to retrieve current GUI buffer. In GUI buffer all GUI 
 *  related information is stored by framework whenever this screen is overwritten.
 *  The application use this function to get GUI buffer pointer of MMI history 
 *  database directly and its life cycle in during this screen is active. If the
 *current screen ID isn't the same with the input parameter, the function will
 *  return NULL GUI buffer pointer.
 * PARAMETERS
 *  scrnid      [IN] Screen ID of screen whose corresponding GUI buffer is to be retrieved.       
 * RETURNS
 *  Pointer to unsigned char pointing to the GUI buffer returned. 
 *****************************************************************************/
U8 *GetCurrGuiBuffer_Ex(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_GET_CUR_GUI_BUF_HDLR, scrnid, currHistoryIndex);
    
    if (-1 == currHistoryIndex)
    {
    		if (historyData[0].scrnID == scrnid)
    		{
            return (historyData[0].guiBuffer);
    		}    		
    } 
    else if (historyData[currHistoryIndex].scrnID == scrnid)
    {
        return (historyData[currHistoryIndex].guiBuffer);
    }
       
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  InitHistory
 * DESCRIPTION
 *  Initialize the history data structure
 *  
 *  Initialize the history data structure
 * PARAMETERS
 *  main_root_ptr       [IN] Reserved. It sould be NULL.       
 *  sub_root_ptr        [IN] The root entry function of the sub LCD.      
 * RETURNS
 *  void
 *****************************************************************************/
void InitHistory(MainLcdHistoryCBPtr main_root_ptr, SubLcdHistoryCBPtr sub_root_ptr)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* U16 count =0; */

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    memset(historyData, 0, sizeof(historyNode) * MAX_HISTORY);
    /* MTK added by JL for history callback */
    memset(historyCBHandler, 0, sizeof(historyCallback) * MAX_HISTORY);

    InitSubLCDHistory(sub_root_ptr);

}


/*****************************************************************************
 * FUNCTION
 *  HistoryDump
 * DESCRIPTION
 *  Dumps the history to file or debug window
 *  
 *  HistoryDump will be used for dbugging purposes
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void HistoryDump(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    count = currHistoryIndex;
    do
    {
        MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_DUMP_HDLR, count, historyData[count].scrnID);

        --count;      

    } while ((count >= MIN_HISTORY) && (historyData[count].entryFuncPtr != NULL));

    SubLCDHistoryDump();
}


/*****************************************************************************
 * FUNCTION
 *  HistoryReplace
 * DESCRIPTION
 *  To replace a specific history
 *  
 *  HistoryReplace will be used for a exist history
 * PARAMETERS
 *  out_scrn_id     [IN]  Specify the Screen ID wants to be replaced.      
 *  in_scrn_id      [IN]  Specify the new Screen ID that wants to be replace with.      
 *  in_src_func     [IN]  The entry function of the new screen.       
 * RETURNS
 *  Returns MMI_TRUE if replace the specified history node succeed; MMI_FALSE otherwise.
 *****************************************************************************/
pBOOL HistoryReplace(U16 out_scrn_id, U16 in_scrn_id, FuncPtr in_src_func)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_HIST_REPLACE_HDLR, out_scrn_id, in_scrn_id);

    for (count = 0; ((count < MAX_HISTORY) && ((count <= currHistoryIndex) && (currHistoryIndex != -1))); count++)
    {
        /* Find the matched source history and then to write into destinate history */
        if (historyData[count].scrnID == out_scrn_id)
        {
            ClearDelScrnIDCallbackHandler(out_scrn_id, NULL);
            historyData[count].scrnID = in_scrn_id;
            historyData[count].entryFuncPtr = in_src_func;
            mmi_free_history_buffer(count);
            return MMI_TRUE;
        }
    }

    return MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  ExecutecurrHisIndEntryFunc
 * DESCRIPTION
 *  executes current history handles  Entry function
 *  
 *  This is used to executes current history handles  Entry function.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void ExecutecurrHisIndEntryFunc(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_EXEC_CURR_HIST_HDLR);
    if (historyData[currHistoryIndex].entryFuncPtr)
    {
        (*(historyData[currHistoryIndex].entryFuncPtr)) ();
    }
}


/*****************************************************************************
 * FUNCTION
 *  DeleteNHistory
 * DESCRIPTION
 *  Deletes 'n' history nodes from current history index
 *  
 *  This shall pop 'n' history nodes without invoking
 *  entry functions of the deleted nodes
 * PARAMETERS
 *  DeleteCount     [IN] Number of nodes to be deleted from the history.       
 * RETURNS
 *  void
 *****************************************************************************/
void DeleteNHistory(U16 DeleteCount)
{
#ifdef NEW_DEL_API
    DeleteHistory(MMI_HIST_TOP_SCREEN, 1, DeleteCount, 0, 0);
#else
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 Index = 0;
    S16 Count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_DEL_NHIST_HDLR, DeleteCount);

    Index = currHistoryIndex;    

    if (Index >= DeleteCount)
    {
        for (Count = DeleteCount; Count >= 1; --Count)
        {
            /* JL, if want to stop to run next decrement will return true. */
            if (decrement() == MMI_HIST_STOP_DELETING)
            {
                /* We abort the process here and don't handle original requirement */
                break;
            }
        }
    }
#endif /* NEW_DEL_API */
}


/*****************************************************************************
 * FUNCTION
 *  DeleteUptoScrID
 * DESCRIPTION
 *  Delete all the nodes in the screen up to specified Screen ID and does not 
 *  execute the Entry Function of the history node beyond the specified Screen 
 *  ID. The specified screen ID should be in the history database, or the function
 *  will return fail.
 * PARAMETERS
 *  scrnid      [IN] Specify the Screen ID up to which one wants to delete the nodes. (not include the specified screen ID).       
 * RETURNS
 *  Returns ST_SUCCESS if delete the history node succeed; ST_FAILURE otherwise.
 *****************************************************************************/
U8 DeleteUptoScrID(U16 scrnid)
{
#ifdef NEW_DEL_API
    return DeleteHistory(MMI_HIST_TOP_SCREEN, 1, 0, scrnid, 0);
#else
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    U8 Status = ST_FAILURE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ST_SUCCESS;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_DEL_UPTO_SCRID_HDLR, scrnid, currHistoryIndex);

    count = currHistoryIndex;

    if (!IsScreenPresent(scrnid))
    {
        return ST_FAILURE;
    }

    do
    {
        if (historyData[currHistoryIndex].scrnID == scrnid)
        {
            Status = ST_SUCCESS;
            break;
        }
        /* JL, if want to stop to run next decrement will return true. */
        if (decrement() == MMI_HIST_STOP_DELETING)
        {
            /* We abort the process here and don't handle original requirement */
            Status = ST_SUCCESS;
            break;
        }

    } while ((count != currHistoryIndex) && (historyData[currHistoryIndex].entryFuncPtr != NULL));
    return Status;
#endif /* NEW_DEL_API */
}


/*****************************************************************************
 * FUNCTION
 *  DeleteNScrId
 * DESCRIPTION
 *  Delete all the nodes in the screen up to specified Screen ID and decrement 
 *  the pointer the history node beyond it but do not execute the entry function. 
 *  The screen ID should be in the history database, or the function will return
 *  fail.
 * PARAMETERS
 *  scrnid      [IN] Specify the Screen ID up to which one wants to delete the nodes. (include the specified screen ID).       
 * RETURNS
 *  Returns ST_SUCCESS if delete the history node succeed; ST_FAILURE otherwise.
 *****************************************************************************/
U8 DeleteNScrId(U16 scrnid)
{
#ifdef NEW_DEL_API
    return DeleteHistory(MMI_HIST_TOP_SCREEN, 1, 0, scrnid, 1);
#else
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    U8 Status = ST_FAILURE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ST_SUCCESS;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_DEL_NSCRID_HDLR, scrnid, currHistoryIndex);

    count = currHistoryIndex;

    if (!IsScreenPresent(scrnid))
    {
        return ST_FAILURE;
    }

    do
    {
        if (historyData[currHistoryIndex].scrnID == scrnid)
        {
            Status = ST_SUCCESS;
            break;
        }
        /* JL, if want to stop to run next decrement will return true. */
        if (decrement() == MMI_HIST_STOP_DELETING)
        {
            /* We abort the process here and don't handle original requirement */
            Status = ST_FAILURE;
            break;
        }

    } while ((count != currHistoryIndex) && (historyData[currHistoryIndex].entryFuncPtr != NULL));

    if (Status)
    {
        decrement();
    }
    return ST_SUCCESS;
#endif /* NEW_DEL_API */
}


/*****************************************************************************
 * FUNCTION
 *  GoBeyondMarkerScr
 * DESCRIPTION
 *  This function deletes the history nodes from the current node up to the node
 *  corresponding to specified Screen ID and execute the entry function of the 
 *  node beyond it. The screen ID should be in the history database, or the 
 *  function will return fail.
 * PARAMETERS
 *  scrnid      [IN] Screen ID of screen beyond which one want to go and execute the Entry Function of that screen.       
 * RETURNS
 *  Returns ST_SUCCESS if go back to the specified history succeed; ST_FAILURE otherwise. 
 *****************************************************************************/
U8 GoBeyondMarkerScr(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count = 0;
    U8 Status = ST_FAILURE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ST_SUCCESS;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_GO_BEYOND_MARKER_SCR_HDLR, scrnid, currHistoryIndex);

    count = currHistoryIndex;

    if (!IsScreenPresent(scrnid))
    {
        return ST_FAILURE;
    }

    if (mmi_is_orderly_exit_screen)
    { 
        IsBackHistory = MMI_TRUE;
        CheckMainLCDHistoryBack = MMI_TRUE;
        bBackHistoryFlag = MMI_TRUE;
        
        ExecuteCurrExitHandler();

        IsBackHistory = MMI_FALSE;
        CheckMainLCDHistoryBack = MMI_FALSE;
        bBackHistoryFlag = MMI_FALSE; 
    }

    do
    {
        if (historyData[currHistoryIndex].scrnID == scrnid)
        {
            Status = ST_SUCCESS;
            break;
        }
        /* JL, if want to stop to run next decrement will return true. */
        if (decrement() == MMI_HIST_STOP_DELETING)
        {
            /* We abort the process here and don't handle original requirement */
            Status = ST_FAILURE;
            break;
        }

    } while ((count != currHistoryIndex) && (historyData[currHistoryIndex].entryFuncPtr != NULL));

    if (Status)
    {
        decrement();
    }
    ExecutePopHistory();

    return ST_SUCCESS;
}



/*****************************************************************************
 * FUNCTION
 *  IsScreenPresent
 * DESCRIPTION
 *  Queries history for presence of a screen Id
 * PARAMETERS
 *  scrnId          [IN] the specified Screen ID which want to query.       
 * RETURNS
 *  Returns MMI_TRUE if the specified Screen ID is in the history database; MMI_FALSE otherwise.
 *****************************************************************************/
pBOOL IsScreenPresent(U16 scrnId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; ((count < MAX_HISTORY) && ((count <= currHistoryIndex) && (currHistoryIndex != -1))); count++)
    {
        if (historyData[count].scrnID == scrnId)
        {
            MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_IS_SCR_PRESENT_HDLR, scrnId, MMI_TRUE);
            return MMI_TRUE;
        }
    }
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_IS_SCR_PRESENT_HDLR, scrnId, MMI_FALSE);
    return MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  IsMainLCDHistoryBack
 * DESCRIPTION
 *  Queries MainLCD history is back now or not
 * PARAMETERS
 *  void
 * RETURNS
 *  Returns MMI_TRUE if the MainLCD history is back now ; MMI_FALSE otherwise.
 *****************************************************************************/
pBOOL IsMainLCDHistoryBack(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return CheckMainLCDHistoryBack;

}


/*****************************************************************************
 * FUNCTION
 *  GetPreviousScrnIdOf
 * DESCRIPTION
 *  Queries previous scrn id of this Id
 * PARAMETERS
 *  scrnId              [IN]   The based Screen ID.     
 *  previousScrnId      [OUT]  The previous Screen ID.       
 * RETURNS
 *  Returns MMI_TRUE if get the previous Screen ID succeed ; MMI_FALSE otherwise. 
 *****************************************************************************/
pBOOL GetPreviousScrnIdOf(U16 scrnId, U16 *previousScrnId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; ((count < MAX_HISTORY) && ((count <= currHistoryIndex) && (currHistoryIndex != -1))); count++)
    {
        if (historyData[count].scrnID == scrnId)
        {
            if ((count - 1) >= 0)
            {
                *previousScrnId = historyData[count - 1].scrnID;
                MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_GET_PREVIOUS_SCR_IDOF_HDLR, scrnId,
                           historyData[count - 1].scrnID);
                return MMI_TRUE;
            }
            MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_GET_PREVIOUS_SCR_IDOF_2_HDLR, scrnId);
            return MMI_FALSE;
        }
    }
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_GET_PREVIOUS_SCR_IDOF_2_HDLR, scrnId);
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  GetNextScrnIdOf
 * DESCRIPTION
 *  Queries next scrn id of this Id
 * PARAMETERS
 *  scrnId          [IN]   The based Screen ID.      
 *  nextScrnId      [OUT]  The next Screen ID.       
 * RETURNS
 *  Returns MMI_TRUE if get the next Screen ID succeed ; MMI_FALSE otherwise.
 *****************************************************************************/
pBOOL GetNextScrnIdOf(U16 scrnId, U16 *nextScrnId)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for (count = 0; ((count < MAX_HISTORY) && ((count <= currHistoryIndex) && (currHistoryIndex != -1))); count++)
    {
        if (historyData[count].scrnID == scrnId)
        {
            if ((count + 1) <= currHistoryIndex)
            {
                *nextScrnId = historyData[count + 1].scrnID;
                return MMI_TRUE;
            }
            return MMI_FALSE;
        }
    }
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  IsCurrMarkerScreen
 * DESCRIPTION
 *  Check if the current screen is  marker screen.
 * PARAMETERS
 *  scrnid      [IN]  The ID of marker screen.       
 * RETURNS
 *  Returns MMI_TRUE if the current screen is marker screen; MMI_FALSE otherwise. 
 *****************************************************************************/
U8 IsCurrMarkerScreen(U16 scrnid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_IS_CUR_MARKER_SCR_HDLR, scrnid, historyData[currHistoryIndex].scrnID);
    return (historyData[currHistoryIndex].scrnID == scrnid);
}


/*****************************************************************************
 * FUNCTION
 *  ExecuteRootMainHistoryScreen
 * DESCRIPTION
 *  To execute the root history screen.
 * PARAMETERS
 *  funcPtr     [IN]        Reserve not use
 * RETURNS
 *  U8
 *****************************************************************************/
U8 ExecuteRootMainHistoryScreen(void *funcPtr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 Status = ST_SUCCESS;
    S16 count = currHistoryIndex;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* reserve not decrement: Memory is not being released bcos of one particular case of keypad lock */

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return ST_SUCCESS;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    /* To make sure the callback will run at topist screen, and callback for APP */
    ExecTopScrnCallbackHandler();

    if (mmi_is_orderly_exit_screen)
    {        
        IsBackHistory = MMI_TRUE;
        CheckMainLCDHistoryBack = MMI_TRUE;
        bBackHistoryFlag = MMI_TRUE;
        
        ExecuteCurrExitHandler();

        IsBackHistory = MMI_FALSE;
        CheckMainLCDHistoryBack = MMI_FALSE;
        bBackHistoryFlag = MMI_FALSE; 
    }
    
    if (currHistoryIndex <= 0)
    {
        IsBackHistory = MMI_TRUE;
        CheckMainLCDHistoryBack = MMI_TRUE;
        bBackHistoryFlag = MMI_TRUE;

        if (historyData[0].entryFuncPtr)
        {
            (*(historyData[0].entryFuncPtr)) ();
        }
        IsBackHistory = MMI_FALSE;
        CheckMainLCDHistoryBack = MMI_FALSE;
        bBackHistoryFlag = MMI_FALSE; 
        return ST_SUCCESS;

    }

    /* down popup all others history to callback for APP */
    bBackHistoryFlag = MMI_TRUE;
    do
    {
        if (count == 0)
        {
            Status = ST_SUCCESS;
            break;
        }
        if (count > 0)
        {
            if (ExecHistoryScrnCallBackHandle(count) == MMI_HIST_STOP_DELETING)
            {
                Status = ST_FAILURE;
                break;
            }
        }
        /* To make sure back to idle screen will be free the history */
        mmi_free_history_buffer(count);

        count--;
    } while ((historyData[count].entryFuncPtr != NULL) && (count > 0));

    currHistoryIndex = count;
    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_EXEC_ROOT_HIST_HDLR, currHistoryIndex, Status);
    
    IsBackHistory = MMI_TRUE;
    if (Status == ST_FAILURE)
    {
        #if 0 /* we may need to keep guiBuffer and inputBuffer */
/* under construction !*/
/* under construction !*/
        #endif

        /* entry itself */
        if (historyData[count].entryFuncPtr)
        {
            (*(historyData[count].entryFuncPtr)) ();
        }
        #if 0 /* We may not need to remove one more node */
/* under construction !*/
/* under construction !*/
        #endif
        decrement();
        #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
        #endif

    }
    else
    {
        if (historyData[currHistoryIndex].entryFuncPtr)
        {
            (*(historyData[currHistoryIndex].entryFuncPtr)) ();
        }
    }
    bBackHistoryFlag = MMI_FALSE;
    IsBackHistory = MMI_FALSE;

    return Status;
}


/*****************************************************************************
 * FUNCTION
 *  DinitHistory
 * DESCRIPTION
 *  Free the history node
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void DinitHistory(void)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_DINIT_HIST_HDLR);

    if (currHistoryIndex > 0)
    {
        for (count = currHistoryIndex; count > 0; --count)
        {
            mmi_free_history_buffer(count);
            memset(&historyData[count], 0, sizeof(historyNode));

        }

    }

    /*
     * Free historyData[0] memory:
     * Here can't use mmi_free_history_buffer() 
     * because currHistoryIndex may be -1 in ExecutePopHistory and then
     * invoke DinitHistory() in EntryIdleScreen()
     */
    if (historyData[0].guiBuffer)
    {
        OslMfree(historyData[0].guiBuffer);
    }
    if (historyData[0].inputBuffer)
    {
        OslMfree(historyData[0].inputBuffer);
    }

    memset(&historyData[0], 0, sizeof(historyData));
    currHistoryIndex = -1;
    bDinitHistoryFlag = MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  SetDelScrnIDCallbackHandler
 * DESCRIPTION
 *  This function is used for register callback function when deleting or exiting
 *  the screens. In some special cases, the application may want to know it screen
 *  is destroyed (exit the screen or delete by other screens). Sometimes, the 
 *  application may want to delete the screens in the history stack, but these 
 *  screens may need to release the resource or not allow for deleting. These 
 *  kind of screens should register history delete callback function, and if the
 *  screen can't be deleted, the function should return MMI_TRUE. 
 * PARAMETERS
 *  ScrnID      [IN]  Specify the Screen ID that  wants to register delete callback function      
 *  funcPtr     [IN]  Pointer to the delete callback function to be registered.      
 * RETURNS
 *  Returns MMI_TRUE if set the delete callback function succeed; MMI_FALSE otherwise.
 *****************************************************************************/
U8 SetDelScrnIDCallbackHandler(U16 ScrnID, HistoryDelCBPtr funcPtr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_SET_SCREEN_ID_CB_HDLR, ScrnID, funcPtr);

    /* MTK added by JL for history callback */
    for (count = 0; count < MAX_HISTORY; count++)
    {
        /* add new one, while scrnID and historydelCBPtr is NULL, means not found we can add a new one. */
        if ((historyCBHandler[count].scrnID == 0) && (historyCBHandler[count].historydelCBPtr == NULL))
        {
            historyCBHandler[count].scrnID = ScrnID;
            historyCBHandler[count].historydelCBPtr = funcPtr;
            return MMI_TRUE;
        }

        /* already exist, to overwrite, while ScrnID and funcPtr are not NULL, and fount ScrnID. */
        /*
         * Leo remove, each screen can only have one callback.
         * if ( (historyCBHandler[count].scrnID == ScrnID) && (historyCBHandler[count].historydelCBPtr != NULL) )
         */
        if (historyCBHandler[count].scrnID == ScrnID)
        {
            historyCBHandler[count].historydelCBPtr = funcPtr;
            return MMI_TRUE;
        }

    }

    MMI_ASSERT(MMI_FALSE);

    return MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  ClearDelScrnIDCallbackHandler
 * DESCRIPTION
 *  Clear callback fucntion for delete screen occur.
 * PARAMETERS
 *  ScrnID      [IN] Specify the Screen ID that  wants to remove the registered delete callback function        
 * RETURNS
 *  Returns MMI_TRUE if succeed; MMI_FALSE otherwise.
 *****************************************************************************/
U8 ClearDelScrnIDCallbackHandler(U16 ScrnID, HistoryDelCBPtr funcPtr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count, found_idx;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_CLR_SCREEN_ID_CB_HDLR, ScrnID, funcPtr);

    /* MTK added by JL for history callback */
    for (count = 0; count < MAX_HISTORY; count++)
    {
        /* found the delete one. */
        if (historyCBHandler[count].scrnID == ScrnID)
        {
            break;
        }
    }

    for (found_idx = count; found_idx < MAX_HISTORY - 1; found_idx++)
    {
        historyCBHandler[found_idx].scrnID = historyCBHandler[found_idx + 1].scrnID;
        historyCBHandler[found_idx].historydelCBPtr = historyCBHandler[found_idx + 1].historydelCBPtr;
    }
    /* set the last one. */
    historyCBHandler[MAX_HISTORY - 1].scrnID = 0;
    historyCBHandler[MAX_HISTORY - 1].historydelCBPtr = NULL;

    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  SearchDelScrnIDCallbackHandler
 * DESCRIPTION
 *  Search index of the delete callback screen.
 * PARAMETERS
 *  ScrnID          [IN]  Specify the Screen ID that wants to search.      
 *  found_idx       [OUT] The index of the delete callback screen.       
 * RETURNS
 *  Returns MMI_TRUE if found the index of the delete callback screen; MMI_FALSE otherwise.
 *****************************************************************************/
static U8 SearchDelScrnIDCallbackHandler(U16 ScrnID, U16 *found_idx)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 count;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    if (redraw_in_small_screen_proceduer())
    {
        return MMI_FALSE;
    }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    for (count = 0; count < MAX_HISTORY; count++)
    {
        /* found the delete one. */
        if (historyCBHandler[count].scrnID == ScrnID)
        {
            MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_SRCH_DEL_SCRN_CB_HDLR, ScrnID, count);

            *found_idx = count;
            return MMI_TRUE;
        }
    }

    return MMI_FALSE;

}


/*****************************************************************************
 * FUNCTION
 *  ExecTopScrnCallbackHandler
 * DESCRIPTION
 *  Check if topist view screen exist in delete screen will be callback.
 * PARAMETERS
 *  void
 * RETURNS
 *  U8 - status
 *****************************************************************************/
static U8 ExecTopScrnCallbackHandler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return ExecTopScrnCallbackHandler_ex(1);
}


/*****************************************************************************
 * FUNCTION
 *  ExecTopScrnCallbackHandler_ex
 * DESCRIPTION
 *  Check if topist view screen exist in delete screen will be callback.
 * PARAMETERS
 *  is_main_hist        [IN]  Is Main LCD or Sub LCD.      
 * RETURNS
 *  Returns MMI_HIST_STOP_DELETING if the screen can't be deleted, MMI_HIST_ALLOW_DELETING otherwise. otherwise.
 *****************************************************************************/
U8 ExecTopScrnCallbackHandler_ex(U8 is_main_hist)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 is_stop_delete = MMI_HIST_ALLOW_DELETING;
    U16 cb_history_index;
    U16 scrnID;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (is_main_hist)
    {
        scrnID = GetExitScrnID();
    }
    else
    {
        scrnID = GetSubLCDExitScrnId();
    }

    if (SearchDelScrnIDCallbackHandler(scrnID, &cb_history_index))
    {
        if (historyCBHandler[cb_history_index].historydelCBPtr)
        {
            is_stop_delete = historyCBHandler[cb_history_index].historydelCBPtr((void*)MMI_HIST_EXIT_SCREEN_TYPE);
        }

        MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_EXEC_TOP_SCRN_CB_HDLR, is_stop_delete);

        ClearDelScrnIDCallbackHandler(historyCBHandler[cb_history_index].scrnID, NULL);
    }

    return is_stop_delete;
}


/*****************************************************************************
 * FUNCTION
 *  ExecHistoryScrnCallBackHandle
 * DESCRIPTION
 *  Check if the history screen exist in delete screen will be callback.
 * PARAMETERS
 *  HistoryIndex        [IN]        
 * RETURNS
 *  U8 - status
 *****************************************************************************/
static U8 ExecHistoryScrnCallBackHandle(U16 HistoryIndex)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return ExecHistoryScrnCallBackHandle_ex(HistoryIndex, 1);
}


/*****************************************************************************
 * FUNCTION
 *  ExecHistoryScrnCallBackHandle_ex
 * DESCRIPTION
 *  Check if the history screen exist in delete screen will be callback.
 * PARAMETERS
 *  HistoryIndex        [IN] The Index of History Node.      
 *  is_main_hist        [IN] Is Main LCD or Sub LCD.       
 * RETURNS
 *  Returns MMI_HIST_STOP_DELETING if the screen can't be deleted, MMI_HIST_ALLOW_DELETING otherwise. otherwise.
 *****************************************************************************/
U8 ExecHistoryScrnCallBackHandle_ex(U16 HistoryIndex, U8 is_main_hist)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /* Not support for stop callback at this funciton */
    U16 cb_history_index;
    U16 scrnID;
    U8 is_stop_allow = MMI_HIST_ALLOW_DELETING;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (is_main_hist)
    {
        /* main LCD history */
        scrnID = historyData[HistoryIndex].scrnID;
    }
    else
    {
        /* sub LCD history */
        scrnID = GetSubLCDScrnId(HistoryIndex);
    }

    if (SearchDelScrnIDCallbackHandler(scrnID, &cb_history_index))
    {
        if (historyCBHandler[cb_history_index].historydelCBPtr)
        {
            is_stop_allow = historyCBHandler[cb_history_index].historydelCBPtr((void*)MMI_HIST_DELETE_SCREEN_TYPE);

            if (is_stop_allow == MMI_HIST_STOP_DELETING)
            {
                MMI_TRACE(MMI_TRACE_G1_FRM, MMI_FRM_INFO_EXEC_HIST_SCRN_CB_HDLR, HistoryIndex);
            }
            else
            {   
                ClearDelScrnIDCallbackHandler(historyCBHandler[cb_history_index].scrnID, NULL);
            }
        }        
    }   

    return is_stop_allow;
}


/*****************************************************************************
 * FUNCTION
 *  set_small_screen
 * DESCRIPTION
 *  Called by category to tell history that the screen being drawn is small.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void set_small_screen(void)
{
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (no_small_screen)
    {
        return;
    }

    if (currHistoryIndex == -1)
    {
        clear_screen();
    }
    small_history_node = 1;
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  mmi_is_redrawing_bk_screens
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
S32 mmi_is_redrawing_bk_screens()
{
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (mmi_execute_scrn_exit_func())
    {
        if (redrawing_old_screens == MMI_HIST_SMALLSCREEN_ACTIVE ||
            redrawing_old_screens == MMI_HIST_SMALLSCREEN_ACTIVE_IN_EXIT_FUNC)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        return (redrawing_old_screens == MMI_HIST_SMALLSCREEN_ACTIVE) ? 1 : 0;
    }
#else /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
    return 0;
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  is_redrawing_old_screens
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  
 *****************************************************************************/
S32 is_redrawing_old_screens()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return mmi_is_redrawing_bk_screens();
}


/*****************************************************************************
 * FUNCTION
 *  reset_small_screen
 * DESCRIPTION
 *  Called by category to tell history that it is exiting from small screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void reset_small_screen(void)
{
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    small_history_node = 0;
    no_small_screen = 0;
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  restore_small_screen
 * DESCRIPTION
 *  Restores small screen
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void restore_small_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    no_small_screen = 0;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  force_no_small_screen
 * DESCRIPTION
 *  Called by Application to disable small screen history saving.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void force_no_small_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    no_small_screen = 1;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  redraw_in_small_screen_proceduer
 * DESCRIPTION
 *  Check if in small screen procedure
 * PARAMETERS
 *  void
 * RETURNS
 *  if in small screen procedure
 *****************************************************************************/
MMI_BOOL redraw_in_small_screen_proceduer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (is_redrawing_old_screens())
    {
        return MMI_TRUE;
    }
    return MMI_FALSE;
}

/* 
 * enable_resized_small_screen(), disable_resized_small_screen(), and whether_no_small_screen()
 * There is no relation with small screen process in history.
 * It's only used for tha WGUI and application and decide to 
 * show the small screen or the normal screen.
 */


/*****************************************************************************
 * FUNCTION
 *  enable_resized_small_screen
 * DESCRIPTION
 *  Called by application to enable the small screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void enable_resized_small_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    small_screen_enabled = 1;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  disable_resized_small_screen
 * DESCRIPTION
 *  Called on exiting the small screen.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void disable_resized_small_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    small_screen_enabled = 0;
#endif 
}


/*****************************************************************************
 * FUNCTION
 *  whether_no_small_screen
 * DESCRIPTION
 *  Tells whether small screen is enabled or not
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
S32 whether_no_small_screen(void)
{
#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return small_screen_enabled;
#else /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
    return 0;
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 
}


/*****************************************************************************
 * FUNCTION
 *  get_range_index
 * DESCRIPTION
 *  get start/end index of given range
 * PARAMETERS
 *  startScrId  [IN]    screen id of start node
 *  bIncStart   [IN]    includes start node or not
 *  count       [IN]    delete count
 *  endScrId    [IN]    screen id of end node
 *  bIncEnd     [IN]    includes end node or not
 *  startIdxPtr [OUT]   pointer to calculated start index
 *  endIdxPtr   [OUT]   pointer to calculated end index
 * RETURNS
 *  success or not
 *****************************************************************************/
__inline static MMI_BOOL get_range_index(U16 startScrId, U8 bIncStart, U16 count, 
                                    U16 endScrId, U8 bIncEnd, S32 *startIdxPtr, S32 *endIdxPtr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 idx, startIdx = -1, endIdx = -1, endIdxTmp = -1;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
 
     /* validate range and get start/end index */
    if ((0 == startScrId) && (0 == endScrId))
    {
        return MMI_FALSE;
    }

    /* get start/end index from given screen id */
    idx = currHistoryIndex;

    if (startScrId > 0)
    {
        for (; idx >= 0; idx--)
        {
            if (historyData[idx].scrnID == startScrId)
            {
                startIdx = idx;
                break;
            }
        }

        /* startIdx not found, reset idx for endIdx */
        if (startIdx < 0)
        {
            idx = currHistoryIndex;
        }
    }

    if (endScrId > 0)
    {
        /* start search from previous idx */
        for (; idx >= 0; idx--)
        {
            if (historyData[idx].scrnID == endScrId)
            {
                endIdx = idx;
                break;
            }
        }       
    }

    /* scr not present in history */
    if (((startScrId > 0) && (startIdx < 0)) || 
        ((endScrId > 0) && (endIdx < 0)))
    {
        return MMI_FALSE;
    }

    /* handle inclusion */
    if (!bIncStart && (startIdx > 0))
    {
        startIdx--;
    }

    /* handle inclusion */
    if (!bIncEnd && (endIdx >= 0))
    {
        endIdx++;
    }

    /* get max range (when count is given) and validate it.
     * Conditions :
     * [1] no startIdx/count/endIdx
     * [2] startIdx exists, no count/endIdx
     * [3] count exists, no startIdx/endIdx
     * [4] endIdx exists, no startIdx/count
     * [5] startIdx/count exist, no endIdx
     * [6] startIdx/endIdx exist, no count
     * [7] endIdx/count exist, no startIdx
     * [8] startIdx/count/endIdx all exist
     */
    if (count > 0)
    {
        if (startIdx >= 0)
        {
            endIdxTmp = startIdx - count + 1;

            if (endIdxTmp < 0)
            {
                /* endIdxTmp is invalid, and will always dominate endIdx (greedy), just return */
                return MMI_FALSE;
            }
        }
        else if (endIdx >= 0)
        {
            /* [7] endIdx/count exist, no startIdx */
            startIdx = endIdx + count - 1;
        }
        else
        {
            /* [3] count exists, no startIdx/endIdx, just return */
            return MMI_FALSE;
        }

    }
    /* count == 0 */
    else if ((startIdx < 0) || (endIdx < 0))
    {
        /* [1] no startIdx/endIdx/count, or
         * [2] no endIdx/count, or
         * [4] no startIdx/count */
        return MMI_FALSE;
    }
    /* else, [6] startIdx/endIdx exist, no count */

    if (endIdx < 0)
    {
        /* [5] startIdx/count exists, no endIdx */
        endIdx = endIdxTmp;
    }
    /* [8] startIdx/endIdx/count exists, do greedy check */
    else if ((endIdxTmp > 0) && (endIdxTmp < endIdx))
    {
        endIdx = endIdxTmp;
    }

    *startIdxPtr = startIdx;
    *endIdxPtr = endIdx;
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  DeleteHistory
 * DESCRIPTION
 *  Delete history
 * 
 * 1. SCR ID should be larger than 0
 * 2. This function is greedy, which means delete histories for 
 *     max( startScrId to endScrId, count)
 * 3. index of startScrId >= index of endScrId
 * 
 * PARAMETERS
 *  startScrId  [IN]    screen id of start node
 *  bIncStart   [IN]    includes start node or not
 *  count       [IN]    delete count
 *  endScrId    [IN]    screen id of end node
 *  bIncEnd     [IN]    includes end node or not
 * RETURNS
 *  no. of nodes deleted
 *****************************************************************************/
U32 DeleteHistory(U16 startScrId, U8 bIncStart, U16 count, U16 endScrId, U8 bIncEnd)
{
    return DeleteHistoryInt(startScrId, bIncStart, count, endScrId, bIncEnd);
}


/*****************************************************************************
 * FUNCTION
 *  DeleteHistoryInt
 * DESCRIPTION
 *  Delete history (internal function)
 * 
 * 1. SCR ID should be larger than 0
 * 2. This function is greedy, which means delete histories for 
 *     max( startScrId to endScrId, count)
 * 3. index of startScrId >= index of endScrId
 * 
 * PARAMETERS
 *  startScrId  [IN]    screen id of start node
 *  bIncStart   [IN]    includes start node or not
 *  count       [IN]    delete count
 *  endScrId    [IN]    screen id of end node
 *  bIncEnd     [IN]    includes end node or not
 * RETURNS
 *  no. of nodes deleted
 *****************************************************************************/
__inline static U32 DeleteHistoryInt(U16 startScrId, U8 bIncStart, U16 count, 
                                     U16 endScrId, U8 bIncEnd)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 delCount = 0;
	U32 ceilingSize = 0;	/* size of ceiling history buffer */
    S32 delIdx, startIdx, endIdx;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_UI_SMALL_SCREEN_SUPPORT__
        if (redraw_in_small_screen_proceduer())
        {
            return delCount;
        }
#endif /* __MMI_UI_SMALL_SCREEN_SUPPORT__ */ 

    MMI_TRACE(TRACE_GROUP_1, MMI_FRM_INFO_DEL_HISTORY_HDLR, 
                startScrId, bIncStart, count, endScrId, bIncEnd);

    /* get start/end index of delete range */
    if (get_range_index(startScrId, bIncStart, count, endScrId, bIncEnd, &startIdx, &endIdx))
    {
        /* both startIdx/endIdx should be valid here */
        MMI_TRACE(TRACE_GROUP_1, MMI_FRM_INFO_DEL_HISTORY_INDEX_HDLR, 
                    currHistoryIndex, startIdx, endIdx);

        ceilingSize = sizeof(historyNode)*(currHistoryIndex - startIdx);
        for (delIdx = startIdx; delIdx >= endIdx; delIdx--)
        {
            /* exe. del cb */
            if (ExecHistoryScrnCallBackHandle((U16)delIdx) == MMI_HIST_STOP_DELETING)
            {
                break;  /* APP forbid to delete */
            }

            mmi_free_history_buffer((U16)delIdx);    /* free buffer */

             /* do history packing */
            if (ceilingSize)
            {
                memmove(&historyData[delIdx], &historyData[delIdx+1], ceilingSize);
            }

            currHistoryIndex--;
        }
        delCount = startIdx - delIdx;

        /* any deletion occurs */
        if (delCount)
        {
            /* clear obsolete history */
            memset(&historyData[currHistoryIndex+1], 0, sizeof(historyNode)*delCount);
        }
    }

    return delCount;
}


typedef struct{
    U16 screen_id;
    FuncPtr entry_func_ptr;
    U8 *input_buffer;    
    U8 *gui_buffer;      
}mmi_frm_tab_history_node_struct;

typedef struct{
    U16     scrn_id;
    FuncPtr entry_func_ptr;
    U8 cur_sel_index;
    U8 tab_page_count;
    mmi_frm_tab_history_node_struct *tab_history_p;
}mmi_frm_tab_group_struct;

static mmi_frm_tab_group_struct  tab_group = {0};
static tab_bar_item_type* g_tab_bar_items_p = NULL;
static S8 g_tab_bar_num = 0;


static mmi_frm_tab_history_node_struct *mmi_frm_find_tab_history(U16 screen_id);
static void mmi_frm_set_tab_bar_items(mmi_frm_tab_struct *tab_pages_info_array, U8 tab_pages_count);
static void mmi_frm_free_tab_bar_items(void);

/*****************************************************************************
 * FUNCTION
 *  general_tab_entry
 * DESCRIPTION
 *  This function is used for create a tab manager and attaches it to an 
 *  instance of a tab group screen. 
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_frm_general_tab_entry(U16 screen_id, FuncPtr entry_func_ptr, mmi_frm_tab_struct *tab_pages_info_array, U8 tab_pages_count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;
    mmi_frm_tab_group_struct *temp_p;    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    if(!IsMainLCDHistoryBack())
    {
        tab_group.cur_sel_index  = 0;
		tab_group.scrn_id = screen_id;
        tab_group.tab_page_count = tab_pages_count;
		tab_group.entry_func_ptr = entry_func_ptr;
        tab_group.tab_history_p  = OslMalloc(sizeof(mmi_frm_tab_history_node_struct)*tab_pages_count);        
        memset(tab_group.tab_history_p, 0, sizeof(mmi_frm_tab_history_node_struct)*tab_pages_count);

        for(i = 0; i<tab_pages_count; i++)
        {
            tab_group.tab_history_p[i].screen_id = tab_pages_info_array[i].screen_id;
            tab_group.tab_history_p[i].entry_func_ptr = tab_pages_info_array[i].tab_entry_func;
        }         
    }
    else
    {
        temp_p = (mmi_frm_tab_group_struct *)GetCurrGuiBuffer(screen_id);

        if (NULL == temp_p)
        {
            return MMI_FALSE;            
        }

        memcpy(&tab_group, temp_p, sizeof(mmi_frm_tab_group_struct));
    }    

    EntryNewScreen(screen_id, mmi_frm_general_tab_exit, NULL, NULL);

    SetDelScrnIDCallbackHandler(screen_id, mmi_frm_general_tab_delete_hdlr);

    mmi_frm_set_tab_bar_items(tab_pages_info_array, tab_pages_count);

    mmi_frm_set_cur_sel_page(tab_group.cur_sel_index);
     
    return MMI_TRUE;

}


/*****************************************************************************
 * FUNCTION
 *  general_tab_exit
 * DESCRIPTION
 *  This function is used for save information about tab group. The 
 *  information include which tab page be selected and the pointer to 
 *  attached tab manager buffer.
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
void mmi_frm_general_tab_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    history history_node;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    memset(&history_node, 0, sizeof(history));
    history_node.scrnID = tab_group.scrn_id;
    history_node.entryFuncPtr = tab_group.entry_func_ptr;
    memcpy(&history_node.guiBuffer, &tab_group, sizeof(mmi_frm_tab_group_struct));
    
    AddHistory(history_node);

    mmi_frm_free_tab_bar_items();

    return;    
}


/*****************************************************************************
 * FUNCTION
 *  general_tab_delete_hdlr
 * DESCRIPTION
 *  This function is used for destroy tab manager.
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
U8 mmi_frm_general_tab_delete_hdlr(void* p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for(i = 0; i < tab_group.tab_page_count; i++)
    {
        if (NULL != tab_group.tab_history_p[i].gui_buffer)
        {
            OslMfree(tab_group.tab_history_p[i].gui_buffer);            
        }
        if (NULL != tab_group.tab_history_p[i].input_buffer)
        {
            tab_group.tab_history_p[i].input_buffer;           
        }               
    }
    
    OslMfree(tab_group.tab_history_p);

    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  
 * DESCRIPTION
 *  
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
static mmi_frm_tab_history_node_struct *mmi_frm_find_tab_history(U16 screen_id) 
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    for(i = 0; i < tab_group.tab_page_count; i++)
    {
        if (tab_group.tab_history_p[i].screen_id == screen_id)
        {
            return &tab_group.tab_history_p[i];
        }
    }

    return NULL;    
}


/*****************************************************************************
 * FUNCTION
 *  add_tab_history
 * DESCRIPTION
 *  This function is used for save information about a tab page in a tab group.
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_frm_add_tab_history(U16 screen_id , history *tab_page_history)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_history_node_struct *temp_p = NULL;
    S32 length = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    temp_p = mmi_frm_find_tab_history(screen_id);

    if (NULL != temp_p)
    {
        memset(temp_p, 0, sizeof(mmi_frm_tab_history_node_struct));
        temp_p->screen_id = tab_page_history->scrnID;
        temp_p->entry_func_ptr = tab_page_history->entryFuncPtr;
       
        temp_p->gui_buffer = OslMalloc(MAX_GUI_BUFFER);
        memcpy(temp_p->gui_buffer, tab_page_history->guiBuffer, MAX_GUI_BUFFER);

        length = mmi_ucs2strlen((PS8) tab_page_history->inputBuffer);
        MMI_ASSERT(length * ENCODING_LENGTH + ENCODING_LENGTH <= MAX_INPUT_BUFFER);
        if (length)
        {
            temp_p->input_buffer = OslMalloc(length * ENCODING_LENGTH + ENCODING_LENGTH);
            mmi_ucs2cpy((PS8) temp_p->input_buffer, (PS8) tab_page_history->inputBuffer);
        }        
    }
    else
    {
        return MMI_FALSE; 
    }

    return MMI_TRUE;        
}





/*****************************************************************************
 * FUNCTION
 *  add_tab_n_history
 * DESCRIPTION
 *  This function is used for save information about a tab page in a tab group.
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_frm_add_tab_n_history(U16 screen_id , history *tab_page_history, U16 size)
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_history_node_struct *temp_p = NULL;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    temp_p = mmi_frm_find_tab_history(screen_id);

    if (NULL != temp_p)
    {
        memset(temp_p, 0, sizeof(mmi_frm_tab_history_node_struct));
        temp_p->screen_id = tab_page_history->scrnID;
        temp_p->entry_func_ptr = tab_page_history->entryFuncPtr;
       
        temp_p->gui_buffer = OslMalloc(MAX_GUI_BUFFER);
        memcpy(temp_p->gui_buffer, tab_page_history->guiBuffer, MAX_GUI_BUFFER);
        
        MMI_ASSERT(size + ENCODING_LENGTH + 2 <= MAX_INPUT_BUFFER);
        temp_p->input_buffer = OslMalloc(size + ENCODING_LENGTH + 2);
        memcpy(temp_p->input_buffer, &size, 2);
        memcpy((PS8) (temp_p->input_buffer + 2), (PS8) tab_page_history->inputBuffer, (U32) size);       
    }
    else
    {
        return MMI_FALSE; 
    }

    return MMI_TRUE;       
}


/*****************************************************************************
 * FUNCTION
 *  set_cur_sel_page
 * DESCRIPTION
 *  This function is selects a tab in the tab group.
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
S32 mmi_frm_set_cur_sel_page (U8 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 old_index;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(index > tab_group.tab_page_count)
    {
        return -1;        
    }
    else
    {
        old_index = tab_group.cur_sel_index;
        tab_group.cur_sel_index = index;
        tab_group.tab_history_p[index].entry_func_ptr();
        return old_index;
    }   
    
}


/*****************************************************************************
 * FUNCTION
 *  get_cur_tab_gui_buffer
 * DESCRIPTION
 *  
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
U8 *mmi_frm_get_cur_tab_gui_buffer(U16 screen_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_history_node_struct *temp_p = NULL;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    temp_p = mmi_frm_find_tab_history(screen_id);

    if (NULL != temp_p)
    {
        return temp_p->gui_buffer;
    }
    else
    {
        return NULL; 
    }
}


/*****************************************************************************
 * FUNCTION
 *  get_cur_tab_input_buffer
 * DESCRIPTION
 *  
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
U8 *mmi_frm_get_cur_tab_input_buffer(U16 screen_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_history_node_struct *temp_p = NULL;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    temp_p = mmi_frm_find_tab_history(screen_id);

    if (NULL != temp_p)
    {
         return temp_p->input_buffer;             
    }
    else
    {
        return NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  get_cur_tab_n_input_buffer
 * DESCRIPTION
 *  
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
U8 *mmi_frm_get_cur_tab_n_input_buffer(U16 screen_id, U16 *size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_frm_tab_history_node_struct *temp_p = NULL;
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    temp_p = mmi_frm_find_tab_history(screen_id);

    if (NULL != temp_p)
    {
        
        if (NULL ==  temp_p->input_buffer)
        {
            *size = 0;
            return NULL;
        }
        else
        {
            memcpy(size, temp_p->input_buffer, 2);
            return ((temp_p->input_buffer) + 2);
        }
    }
    else
    {
        return NULL; 
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_general_tab_l_arrow_key_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
void mmi_frm_general_tab_l_arrow_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (tab_group.cur_sel_index > 0)
    {
        tab_group.cur_sel_index--;
    }
    else
    {
        tab_group.cur_sel_index = tab_group.tab_page_count - 1;
    }
    mmi_frm_set_cur_sel_page(tab_group.cur_sel_index);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_general_tab_r_arrow_key_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
void mmi_frm_general_tab_r_arrow_key_hdlr(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (tab_group.cur_sel_index < tab_group.tab_page_count - 1)
    {
        tab_group.cur_sel_index++;
    }
    else
    {
        tab_group.cur_sel_index = 0;
    }
    mmi_frm_set_cur_sel_page(tab_group.cur_sel_index);
    
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_tab_bar_items
 * DESCRIPTION
 *  
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_frm_set_tab_bar_items(mmi_frm_tab_struct *tab_pages_info_array, U8 tab_pages_count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(tab_pages_count > 0);
    MMI_ASSERT(NULL == g_tab_bar_items_p);
    g_tab_bar_items_p = OslMalloc(sizeof(tab_bar_item_type)*tab_pages_count);
    g_tab_bar_num = tab_pages_count;

    for (i = 0; i <tab_pages_count; i++)
    {
        g_tab_bar_items_p[i].icon  = tab_pages_info_array[i].tab_icon;
        g_tab_bar_items_p[i].text  = (UI_string_type)tab_pages_info_array[i].tab_string;
        g_tab_bar_items_p[i].flags = 0;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_set_tab_bar_items
 * DESCRIPTION
 *  
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
static void mmi_frm_free_tab_bar_items(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    OslMfree(g_tab_bar_items_p); 
    g_tab_bar_items_p = NULL;
    g_tab_bar_num = 0;     
}


/*****************************************************************************
 * FUNCTION
 *  mmi_frm_get_tab_bar_items
 * DESCRIPTION
 *  
 * PARAMETERS
 *   
 * RETURNS
 *  
 *****************************************************************************/
MMI_BOOL mmi_frm_get_tab_bar_items(tab_bar_item_type *tab_bar_items_p, S8 *tabs_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_tab_bar_num == 0)
    {
        return MMI_FALSE;       
    }

    *tabs_p = g_tab_bar_num;
    
    memcpy(tab_bar_items_p, g_tab_bar_items_p, sizeof(tab_bar_item_type)*g_tab_bar_num);

    return MMI_TRUE;    
}


